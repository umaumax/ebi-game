<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãˆã³ã¡ã‚ƒã‚“ï¼ˆä»®ï¼‰</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ¦</text></svg>">
    <meta property="og:title" content="ãˆã³ã¡ã‚ƒã‚“ï¼ˆä»®ï¼‰">
    <meta property="og:description" content="è¿«ã‚Šãã‚‹å¤©æ•µã‚’é¿ã‘ãªãŒã‚‰ã©ã‚Œã ã‘é•·ãæ³³ã’ã‚‹ã‹ã‚’ç«¶ã†ã‚·ãƒ³ãƒ—ãƒ«å›é¿ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ">
    <meta property="og:image" content="https://umaumax.github.io/ebi-game/ebi-game-screenshot.png">
    <meta property="og:url" content="https://umaumax.github.io/ebi-game/">
    <meta name="twitter:card" content="summary_large_image">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #87CEEB; /* æ°´è‰² */
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: manipulation; /* ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—æ‹¡å¤§é˜²æ­¢ */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 #000;
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
        }
        .level-display {
            position: absolute;
            top: 20px;
            right: 80px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 #000;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
        }
        .message-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px 40px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            pointer-events: auto; /* ãƒœã‚¿ãƒ³ãªã©ã‚’æŠ¼ã›ã‚‹ã‚ˆã†ã« */
        }
        h1 {
            margin: 0 0 10px 0;
            color: #FF6F61;
            font-size: 32px;
        }
        p {
            margin: 10px 0;
            color: #333;
            font-size: 16px;
            line-height: 1.5;
        }
        .blink {
            animation: blinker 0.8s ease-in-out infinite alternate;
            background-color: #FF6F61;
            color: white;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 30px;
            margin-top: 20px;
            display: inline-block;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 111, 97, 0.4);
            user-select: none;
            -webkit-user-select: none;
        }
        @keyframes blinker {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.1); opacity: 0.9; }
        }
        /* ã‚¹ãƒãƒ›å‘ã‘èª¿æ•´ */
        @media (max-width: 600px) {
            h1 { font-size: 24px; }
            p { font-size: 14px; }
        }
        .life-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 30px;
            color: #FF6F61;
        }
        .level-up-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
            opacity: 0;
        }
        .level-up-msg.animate {
            animation: fadeUp 2s forwards;
        }
        @keyframes fadeUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -150%) scale(1.5); }
        }
        #pause-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            font-weight: bold;
            font-size: 20px;
            color: #333;
            pointer-events: auto;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        .warning-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: bold;
            color: #FF0000;
            text-shadow: 3px 3px 0 #000;
            display: none;
            z-index: 200;
        }
        .warning-msg.active {
            display: block;
            animation: blinker 0.2s linear infinite;
        }
        .difficulty-select {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .diff-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            font-weight: bold;
            cursor: pointer;
            color: white;
            font-size: 16px;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="score-display">
        DISTANCE: <span id="score">0</span>m<br>
        <span style="font-size: 0.6em; color: #eee;">HI: <span id="high-score">0</span>m</span>
    </div>
    
    <div class="level-display">LV: <span id="level">1</span></div>

    <div id="life-display" class="life-display">â¤â¤â¤</div>
    
    <div id="level-up-msg" class="level-up-msg">LEVEL UP!</div>
    
    <div id="pause-btn">II</div>

    <div id="warning-msg" class="warning-msg">WARNING!</div>

    <div id="start-screen" class="message-box">
        <h1>ãˆã³ã¡ã‚ƒã‚“ï¼ˆä»®ï¼‰</h1>
        <p>æ³³ãï¼šã‚¿ãƒƒãƒ— / ã‚¹ãƒšãƒ¼ã‚¹</p>
        <p>é›£æ˜“åº¦ã‚’é¸ã‚“ã§ã‚¹ã‚¿ãƒ¼ãƒˆ</p>
        <div class="difficulty-select">
            <button id="btn-easy" class="diff-btn" style="background-color: #4CAF50;">EASY</button>
            <button id="btn-normal" class="diff-btn" style="background-color: #2196F3;">NORMAL</button>
            <button id="btn-hard" class="diff-btn" style="background-color: #f44336;">HARD</button>
        </div>
    </div>

    <div id="gameover-screen" class="message-box" style="display: none;">
        <h1>GAME OVER</h1>
        <img id="screenshot" style="width: 100%; max-width: 400px; height: auto; border-radius: 10px; margin: 10px auto; border: 2px solid #333; display: block;">
        <p>è¨˜éŒ²: <span id="final-score">0</span>m</p>
        <p id="rank-display" style="font-size: 20px; color: #FFD700; font-weight: bold; text-shadow: 1px 1px 2px black; margin: 5px 0;"></p>
        <p style="color: #FF4500; font-weight: bold;">æ­»å› : <span id="death-reason">ä¸æ˜</span></p>
        <div class="blink">TAP TO RETRY</div>
        <button id="gameover-download-ss-btn" class="diff-btn" style="background-color: #00BCD4; margin-top: 10px; display: block; margin-left: auto; margin-right: auto;">ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’ä¿å­˜</button>
        <button id="replay-btn" style="margin-top: 10px; padding: 10px 20px; background-color: #FF8C00; color: white; border: none; border-radius: 20px; font-family: 'M PLUS Rounded 1c', sans-serif; font-weight: bold; cursor: pointer; font-size: 14px; display: block; margin-left: auto; margin-right: auto;">ğŸ¥ ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆå†ç”Ÿ</button>
        <button id="share-btn" style="margin-top: 15px; padding: 10px 20px; background-color: #000; color: white; border: none; border-radius: 20px; font-family: 'M PLUS Rounded 1c', sans-serif; font-weight: bold; cursor: pointer; font-size: 14px;">Xã§ã‚·ã‚§ã‚¢</button>
    </div>

    <div id="pause-screen" class="message-box" style="display: none;">
        <h1>PAUSED</h1>
        <button id="download-ss-btn" class="diff-btn" style="background-color: #00BCD4; margin-top: 10px;">ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’ä¿å­˜</button>
        <div class="blink">TAP TO RESUME</div>
    </div>

    <div id="replay-ui" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); pointer-events: auto; display: none;">
        <button id="skip-replay-btn" class="diff-btn" style="background-color: #757575;">SKIP</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ã‚²ãƒ¼ãƒ ä»•æ§˜å®šæ•°
 */
const CONSTANTS = {
    GRAVITY: 0.15,
    JUMP_FORCE_Y: -5.0, // ä¸Šæ–¹å‘ã¸ã®åŠ›
    JUMP_FORCE_X: -4.0, // å¾Œæ–¹ã¸ã®åŠ›ï¼ˆãƒãƒƒã‚¯ï¼‰
    AUTO_FORWARD_SPEED: 1.5, // ä½•ã‚‚ã—ãªã„æ™‚ã«å‰ï¼ˆå³ï¼‰ã«æˆ»ã‚‹åŠ›
    SCROLL_SPEED: 3.5, // èƒŒæ™¯ãƒ»æ•µã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦
    SHRIMP_COLOR: '#FF6F61',
    SHRIMP_BASE_SIZE: 20,
    MAX_LIVES: 5,
    BOSS_INTERVAL: 300 // ãƒœã‚¹å‡ºç¾é–“éš”(m)
};

/**
 * ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ç®¡ç†
 */
const STATE = {
    START: 0,
    PLAYING: 1,
    GAMEOVER: 2,
    PAUSED: 3,
    BITTEN: 4, // ãƒ’ãƒ©ãƒ¡ã«é£Ÿã¹ã‚‰ã‚Œã¦ã„ã‚‹çŠ¶æ…‹
    REPLAY: 5  // ãƒªãƒ—ãƒ¬ã‚¤å†ç”Ÿä¸­
};

/**
 * éŸ³å£°ç®¡ç†ã‚¯ãƒ©ã‚¹ (Web Audio API)
 */
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.bgmTimer = null;
        this.bgmStep = 0;
        this.bgmTempo = 250;
        this.bgmPitchRate = 1.0;
    }

    init() {
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    playTone(freq, type, duration, vol = 0.1) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playJump() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(300, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }

    playHit() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }

    playItem() {
        this.playTone(1200, 'sine', 0.1, 0.1);
        setTimeout(() => this.playTone(1800, 'sine', 0.2, 0.1), 50);
    }
    
    playBubble() {
        this.playTone(800 + Math.random() * 200, 'sine', 0.05, 0.02);
    }

    setBGMParams(score) {
        // ã‚¹ã‚³ã‚¢(æ·±åº¦)ã«å¿œã˜ã¦ãƒ†ãƒ³ãƒã‚’é…ãã€ãƒ”ãƒƒãƒã‚’ä½ãã™ã‚‹
        // 0m: 250ms, 1.0
        // 2000m: 400ms, 0.6
        const ratio = Math.min(score / 2000, 1.0);
        this.bgmTempo = 250 + ratio * 150;
        this.bgmPitchRate = 1.0 - ratio * 0.4;
    }

    startBGM() {
        if (this.bgmTimer) return;
        this.playBGMStep();
    }

    playBGMStep() {
        const notes = [196, 0, 261, 0, 220, 0, 196, 0]; // G3, C4, A3, G3
        
        if (this.ctx.state !== 'suspended') {
            const baseFreq = notes[this.bgmStep % notes.length];
            if (baseFreq > 0) {
                this.playTone(baseFreq * this.bgmPitchRate, 'triangle', 0.2, 0.03);
            }
        }
        this.bgmStep++;
        this.bgmTimer = setTimeout(() => this.playBGMStep(), this.bgmTempo);
    }

    stopBGM() {
        if (this.bgmTimer) {
            clearTimeout(this.bgmTimer);
            this.bgmTimer = null;
        }
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.state = STATE.START;
        this.score = 0;
        this.highScore = parseInt(localStorage.getItem('ebi_highscore')) || 0;
        this.frameCount = 0;
        this.lives = 3;
        this.level = 0;
        this.scrollSpeed = CONSTANTS.SCROLL_SPEED;
        this.difficulty = 'NORMAL';
        this.scrollOffset = 0;
        this.isRapidCurrent = false;
        this.rapidCurrentTimer = 0;
        this.streamLines = []; // æ¿€æµã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        this.replayBuffer = []; // ãƒªãƒ—ãƒ¬ã‚¤ç”¨ãƒ‡ãƒ¼ã‚¿
        this.replayIndex = 0;
        this.replayDummies = {}; // ãƒªãƒ—ãƒ¬ã‚¤æç”»ç”¨ã®ãƒ€ãƒŸãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        this.lastBossDistance = 0;
        this.sound = new SoundManager();

        this.player = new Shrimp(this.width / 3, this.height / 2);
        this.enemies = [];
        this.items = []; // ãƒ‘ãƒ¼ãƒ«ãªã©
        this.decorations = []; // ã‚ã‹ã‚ã€å²©ã€ã‚µãƒ³ã‚´
        this.particles = [];
        this.floatingTexts = []; // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ

        // UIè¦ç´ 
        this.uiScore = document.getElementById('score');
        this.uiLevel = document.getElementById('level');
        this.uiLife = document.getElementById('life-display');
        this.uiHighScore = document.getElementById('high-score');
        this.uiFinalScore = document.getElementById('final-score');
        this.uiDeathReason = document.getElementById('death-reason');
        this.uiRank = document.getElementById('rank-display');
        this.uiLevelUp = document.getElementById('level-up-msg');
        this.uiPauseBtn = document.getElementById('pause-btn');
        this.uiWarning = document.getElementById('warning-msg');
        this.screenStart = document.getElementById('start-screen');
        this.screenGameOver = document.getElementById('gameover-screen');
        this.screenPause = document.getElementById('pause-screen');

        this.screenshotTaken = false;

        // UI for replay
        this.uiReplay = document.getElementById('replay-ui');
        this.btnSkipReplay = document.getElementById('skip-replay-btn');

        // ãƒªãƒ—ãƒ¬ã‚¤ç”¨ãƒ€ãƒŸãƒ¼ã®åˆæœŸåŒ–
        this.initReplayDummies();

        // é›£æ˜“åº¦ãƒœã‚¿ãƒ³
        this.btnEasy = document.getElementById('btn-easy');
        this.btnNormal = document.getElementById('btn-normal');
        this.btnHard = document.getElementById('btn-hard');

        const startHandler = (diff) => (e) => {
            e.stopPropagation();
            if (this.state !== STATE.START) return;
            this.sound.init();
            this.startGame(diff);
        };
        ['mousedown', 'touchstart'].forEach(evt => this.btnEasy.addEventListener(evt, startHandler('EASY')));
        ['mousedown', 'touchstart'].forEach(evt => this.btnNormal.addEventListener(evt, startHandler('NORMAL')));
        ['mousedown', 'touchstart'].forEach(evt => this.btnHard.addEventListener(evt, startHandler('HARD')));

        // ãƒªãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³
        this.btnReplay = document.getElementById('replay-btn');
        const replayHandler = (e) => { e.stopPropagation(); this.startReplay(); };
        ['mousedown', 'touchstart'].forEach(evt => this.btnReplay.addEventListener(evt, replayHandler));

        // ã‚¹ã‚­ãƒƒãƒ—ãƒœã‚¿ãƒ³
        const skipReplayHandler = (e) => { e.stopPropagation(); this.gameOver(this.deathReason); };
        ['mousedown', 'touchstart'].forEach(evt => this.btnSkipReplay.addEventListener(evt, skipReplayHandler));

        // ã‚¹ã‚¯ã‚·ãƒ§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
        this.btnDownloadSS = document.getElementById('download-ss-btn');
        const downloadSSHandler = (e) => {
            e.stopPropagation();
            const link = document.createElement('a');
            link.download = `ebi-game-screenshot-${Date.now()}.png`;
            link.href = this.canvas.toDataURL('image/png');
            link.click();
        };
        ['mousedown', 'touchstart'].forEach(evt => this.btnDownloadSS.addEventListener(evt, downloadSSHandler));

        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®ã‚¹ã‚¯ã‚·ãƒ§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
        this.btnGameoverDownloadSS = document.getElementById('gameover-download-ss-btn');
        const gameoverDownloadSSHandler = (e) => {
            e.stopPropagation();
            const link = document.createElement('a');
            link.download = `ebi-game-result-${Date.now()}.png`;
            link.href = this.gameOverScreenshotURL || this.canvas.toDataURL('image/png');
            link.click();
        };
        ['mousedown', 'touchstart'].forEach(evt => this.btnGameoverDownloadSS.addEventListener(evt, gameoverDownloadSSHandler));

        // ã‚·ã‚§ã‚¢ãƒœã‚¿ãƒ³
        this.btnShare = document.getElementById('share-btn');
        this.btnShare.addEventListener('click', (e) => {
            e.stopPropagation();
            const text = `ãˆã³ã¡ã‚ƒã‚“ï¼ˆä»®ï¼‰ã§${Math.floor(this.score)}mæ³³ãã¾ã—ãŸï¼\næ­»å› : ${this.deathReason}\né›£æ˜“åº¦: ${this.difficulty}`;
            const baseUrl = 'https://umaumax.github.io/ebi-game/';
            const hashtags = 'ãˆã³ã¡ã‚ƒã‚“ã‚²ãƒ¼ãƒ ';

            // OGPç”»åƒã‚’å‹•çš„ã«ç”Ÿæˆã™ã‚‹ãŸã‚ã®URLã‚’ä½œæˆ
            const ogpParams = `score=${Math.floor(this.score)}&rank=${encodeURIComponent(this.getRank(this.score))}&reason=${encodeURIComponent(this.deathReason)}`;
            // ã“ã®URLã¯Vercelç­‰ã®ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹é–¢æ•°ã‚’æƒ³å®šã—ã¦ã„ã¾ã™
            const ogpImageUrl = `https://your-serverless-function-url/api/ogp?${ogpParams}`;
            const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(baseUrl)}&hashtags=${encodeURIComponent(hashtags)}`;
            window.open(twitterUrl, '_blank');
        });

        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        
        this.updateLifeDisplay();
        this.uiHighScore.innerText = this.highScore;
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    initReplayDummies() {
        // ã‚¯ãƒ©ã‚¹åã‹ã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å¼•ã‘ã‚‹ã‚ˆã†ã«ãƒãƒƒãƒ—ã‚’ä½œæˆ
        const classes = [
            Fish, Sardine, Tuna, Shark, Anglerfish, Hook, Net, Squid, Flatfish, 
            SeaUrchin, Octopus, Porcupinefish, Needle, Whirlpool, Whale,
            Pearl, Plankton, FriendShrimp, Clownfish, GardenEel,
            Seaweed, RuggedTerrain, Coral, StreamLine, Bubble
        ];
        classes.forEach(cls => {
            try {
                // å¼•æ•°ãªã—ã€ã‚ã‚‹ã„ã¯é©å½“ãªå¼•æ•°ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
                // ä¸€éƒ¨ã®ã‚¯ãƒ©ã‚¹ã¯å¼•æ•°ãŒå¿…è¦ã ãŒã€æç”»ã«ä½¿ã†ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯å¾Œã§ä¸Šæ›¸ãã™ã‚‹ã®ã§ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã‘ã‚Œã°OK
                if (cls === Shark) this.replayDummies[cls.name] = new cls(0, 0, null);
                else if (cls === Porcupinefish) this.replayDummies[cls.name] = new cls(0, 0, this);
                else this.replayDummies[cls.name] = new cls(0, 0);
            } catch (e) {
                console.error("Dummy init failed for", cls.name, e);
            }
        });
        this.replayDummies['Shrimp'] = new Shrimp(0, 0);
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    }

    setupInput() {
        const action = (e) => {
            this.sound.init(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’é–‹å§‹
            
            // ãƒœã‚¿ãƒ³æ“ä½œæ™‚ã¯ä½•ã‚‚ã—ãªã„ï¼ˆãƒœã‚¿ãƒ³ã®ãƒãƒ³ãƒ‰ãƒ©ã«ä»»ã›ã‚‹ï¼‰
            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;

            // ãƒãƒ¼ã‚ºãƒœã‚¿ãƒ³
            if (e.target === this.uiPauseBtn) {
                this.togglePause();
                return;
            }

            if (e.type === 'keydown' && !(e.code === 'Space')) return;
            if (e.type === 'touchstart') e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢

            if (this.state === STATE.START) {
                // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚‚NORMALã§é–‹å§‹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
                if (e.type === 'keydown' && e.code === 'Space') {
                    this.btnNormal.style.transform = 'scale(1.1)';
                    this.btnNormal.style.boxShadow = '0 0 15px #2196F3';
                    setTimeout(() => { this.btnNormal.style.transform = ''; this.btnNormal.style.boxShadow = ''; }, 200);
                    this.startGame('NORMAL');
                }
            } else if (this.state === STATE.PLAYING) {
                this.player.jump();
                this.sound.playJump();
            } else if (this.state === STATE.PAUSED) {
                this.togglePause();
            } else if (this.state === STATE.GAMEOVER) {
                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒªã‚¹ã‚¿ãƒ¼ãƒˆå¯èƒ½ã«ï¼ˆèª¤æ“ä½œé˜²æ­¢ï¼‰
                if (this.frameCount > 30) this.resetGame();
            } else if (this.state === STATE.REPLAY) {
                // ãƒªãƒ—ãƒ¬ã‚¤ä¸­ã¯ã‚¿ãƒƒãƒ—ã§çµ‚äº†
                this.gameOver(this.deathReason);
            }
        };

        window.addEventListener('keydown', action);
        window.addEventListener('touchstart', action, { passive: false });
        window.addEventListener('mousedown', action);
    }

    togglePause() {
        if (this.state === STATE.PLAYING) {
            this.state = STATE.PAUSED;
            this.screenPause.style.display = 'block';
            this.uiPauseBtn.style.display = 'none';
            this.sound.stopBGM();
        } else if (this.state === STATE.PAUSED) {
            this.state = STATE.PLAYING;
            this.screenPause.style.display = 'none';
            this.uiPauseBtn.style.display = 'flex';
            this.sound.startBGM();
        }
    }

    startGame(difficulty = 'NORMAL') {
        this.difficulty = difficulty;
        this.state = STATE.PLAYING;
        this.screenStart.style.display = 'none';
        this.screenGameOver.style.display = 'none';
        this.score = 0;
        this.lives = 3;
        this.updateLifeDisplay();
        this.level = 0;
        
        // é›£æ˜“åº¦ã«ã‚ˆã‚‹åˆæœŸé€Ÿåº¦è¨­å®š
        if (this.difficulty === 'EASY') this.scrollSpeed = 3.0;
        else if (this.difficulty === 'HARD') this.scrollSpeed = 5.0;
        else this.scrollSpeed = CONSTANTS.SCROLL_SPEED; // 3.0

        this.lastBossDistance = 0;
        this.uiWarning.classList.remove('active');
        this.frameCount = 0;
        this.scrollOffset = 0;
        this.isRapidCurrent = false;
        this.rapidCurrentTimer = 0;
        this.streamLines = [];
        this.screenshotTaken = false;
        this.replayBuffer = [];
        this.sound.startBGM();
        this.enemies = [];
        this.items = [];
        this.decorations = [];
        this.particles = [];
        this.floatingTexts = [];
        this.player.reset(this.width / 3, this.height / 2);
        this.updatePlayerSize();
    }

    resetGame() {
        this.state = STATE.START;
        this.screenStart.style.display = 'block';
        this.screenGameOver.style.display = 'none';
        this.sound.stopBGM();
    }

    startReplay() {
        this.state = STATE.REPLAY;
        this.screenGameOver.style.display = 'none';
        this.uiReplay.style.display = 'block'; 
        // æœ€å¾Œã®3ç§’é–“ã ã‘å†ç”Ÿ (30fps * 3s = 90ãƒ•ãƒ¬ãƒ¼ãƒ )
        this.replayIndex = Math.max(0, this.replayBuffer.length - 90);
    }

    updateLifeDisplay() {
        let hearts = '';
        for(let i=0; i<this.lives; i++) hearts += 'â¤';
        this.uiLife.innerText = hearts;
    }

    updatePlayerSize() {
        // ãƒ©ã‚¤ãƒ•ãŒå¢—ãˆã‚‹ã¨ã‚µã‚¤ã‚ºï¼ˆå½“ãŸã‚Šåˆ¤å®šï¼‰ãŒå¤§ãããªã‚‹ä»•æ§˜
        // ãƒ©ã‚¤ãƒ•3ã‚’åŸºæº–(20px)ã¨ã—ã€å¢—æ¸›ã§ã‚µã‚¤ã‚ºå¤‰åŒ–
        if (this.player) {
            const size = CONSTANTS.SHRIMP_BASE_SIZE + (this.lives - 3) * 5;
            this.player.radius = Math.max(10, size); // æœ€å°10pxã¯ç¢ºä¿
        }
    }

    hitPlayer(reason = "ä¸æ˜") {
        if (this.player.isInvincible) return;

        this.sound.playHit();
        this.lives--;
        this.updateLifeDisplay();
        this.updatePlayerSize();
        this.deathReason = reason;
        
        if (this.lives <= 0) {
            this.gameOver(reason);
        } else {
            // ãƒ€ãƒ¡ãƒ¼ã‚¸æ¼”å‡ºã¨ç„¡æ•µæ™‚é–“
            this.player.setInvincible(60); // 60ãƒ•ãƒ¬ãƒ¼ãƒ ç„¡æ•µ
            // ç”»é¢ã‚’èµ¤ããƒ•ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ã‚‹ãªã©ã®æ¼”å‡ºã‚‚å¯
            this.ctx.fillStyle = 'rgba(255,0,0,0.3)';
            this.ctx.fillRect(0,0,this.width,this.height);
        }
    }

    triggerFlatfishDeath(flatfish) {
        // ãƒ’ãƒ©ãƒ¡ã«é£Ÿã¹ã‚‰ã‚Œã‚‹æ¼”å‡ºé–‹å§‹
        this.sound.playHit();
        this.state = STATE.BITTEN;
        this.bittenTimer = 0;
        this.killerEnemy = flatfish;
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ’ãƒ©ãƒ¡ã®ä½ç½®ã«å›ºå®šï¼ˆæ•é£Ÿã•ã‚ŒãŸè¡¨ç¾ï¼‰
        this.player.x = flatfish.x;
        this.player.y = flatfish.y;
        this.deathReason = "ãƒ’ãƒ©ãƒ¡ã«é£Ÿã¹ã‚‰ã‚ŒãŸ";
    }

    getGroundY(x) {
        const base = this.height - 50;
        // ã†ã­ã†ã­ã•ã›ã‚‹
        return base + Math.sin((x + this.scrollOffset) * 0.005) * 20 + Math.sin((x + this.scrollOffset) * 0.02) * 10;
    }

    addFloatingText(x, y, text, color) {
        this.floatingTexts.push(new FloatingText(x, y, text, color));
    }

    getRank(score) {
        if (score < 100) return "è¿·å­ã®ã‚¨ãƒ“";
        if (score < 300) return "ãŠæ•£æ­©ã‚¨ãƒ“";
        if (score < 500) return "å†’é™ºè€…";
        if (score < 1000) return "æ·±æµ·ã®æ—…äºº";
        if (score < 2000) return "æ·±æ·µã‚’è¦—ãè€…";
        if (score < 3000) return "æ·±æµ·ã®ä¸»";
        if (score < 5000) return "ä¼èª¬ã®æµ·è€";
        return "æ·±æµ·ã®è¦‡è€…";
    }

    gameOver(reason) {
        this.state = STATE.GAMEOVER;
        this.screenGameOver.style.display = 'block';
        
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼UIã‚’æç”»ã—ãŸçŠ¶æ…‹ã®Canvasã‚’ä¿å­˜
        if (!this.screenshotTaken) {
            this.ctx.save();
            
            // èƒŒæ™¯ã‚’å°‘ã—æš—ãã™ã‚‹
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            this.ctx.fillRect(0, 0, this.width, this.height);

            // GAME OVER
            this.ctx.fillStyle = '#FF4500';
            this.ctx.font = 'bold 48px "M PLUS Rounded 1c"';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.shadowColor = 'white';
            this.ctx.shadowBlur = 10;
            this.ctx.fillText("GAME OVER", this.width / 2, this.height / 2 - 80);
            this.ctx.shadowBlur = 0;

            // è¨˜éŒ² (Score)
            this.ctx.fillStyle = 'white';
            this.ctx.font = 'bold 32px "M PLUS Rounded 1c"';
            this.ctx.fillText(`è¨˜éŒ²: ${Math.floor(this.score)}m`, this.width / 2, this.height / 2);

            // ç§°å· (Rank)
            this.ctx.fillStyle = '#FFD700';
            this.ctx.font = 'bold 24px "M PLUS Rounded 1c"';
            this.ctx.fillText(`ç§°å·: ${this.getRank(this.score)}`, this.width / 2, this.height / 2 + 40);

            this.ctx.restore();
            this.gameOverScreenshotURL = this.canvas.toDataURL('image/png');
            this.screenshotTaken = true;
        }

        // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆç”Ÿæˆ
        const dataUrl = this.canvas.toDataURL();
        document.getElementById('screenshot').src = dataUrl;

        this.sound.stopBGM();
        this.uiReplay.style.display = 'none'; // ã‚¹ã‚­ãƒƒãƒ—ãƒœã‚¿ãƒ³ã‚’éš ã™
        this.uiFinalScore.innerText = Math.floor(this.score);
        this.uiRank.innerText = `ç§°å·: ${this.getRank(this.score)}`;
        this.uiDeathReason.innerText = reason || this.deathReason;
        
        // ãƒªãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºåˆ¶å¾¡ï¼ˆãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã®ã¿ï¼‰
        if (this.replayBuffer.length > 0) {
            this.btnReplay.style.display = 'block';
        } else {
            this.btnReplay.style.display = 'none';
        }

        if (this.score > this.highScore) {
            this.highScore = Math.floor(this.score);
            localStorage.setItem('ebi_highscore', this.highScore);
            this.uiHighScore.innerText = this.highScore;
        }
        this.frameCount = 0; // ãƒªã‚¹ã‚¿ãƒ¼ãƒˆå¾…ã¡æ™‚é–“ç”¨
    }

    spawnEnemy() {
        // ãƒœã‚¹å‡ºç¾ä¸­ã¯é›‘é­šæ•µã‚’å‡ºã•ãªã„
        if (this.uiWarning.classList.contains('active') || this.enemies.some(e => e instanceof Whale)) {
            return;
        }

        // é›£æ˜“åº¦èª¿æ•´: æ™‚é–“çµŒéã§å‡ºç¾é »åº¦ãŒä¸ŠãŒã‚‹
        // è·é›¢ãŒé€²ã‚€ã«ã¤ã‚Œã¦éšœå®³ç‰©ã®éš™é–“ã‚’ç‹­ãã™ã‚‹ï¼ˆå‡ºç¾é »åº¦ã‚¢ãƒƒãƒ—ï¼‰
        let baseRate = 90;
        let minRate = 25;
        
        if (this.difficulty === 'EASY') {
            baseRate = 100;
            minRate = 35;
        } else if (this.difficulty === 'HARD') {
            baseRate = 45;
            minRate = 12;
        } else {
            baseRate = 70;
            minRate = 20;
        }

        const spawnRate = Math.max(minRate, baseRate - Math.floor(this.score / 25));
        
        if (this.frameCount % spawnRate === 0) {
            const type = Math.random();
            const isDeep = this.score > 1000; // 1000mè¶…ãˆãŸã‚‰æ·±æµ·

            // æ·±æµ·ãªã‚‰ä¸€å®šç¢ºç‡ã§æç¯é®Ÿé±‡
            if (isDeep && Math.random() < 0.3) {
                this.enemies.push(new Anglerfish(this.width, Math.random() * (this.height - 100) + 50));
            } else if (type < 0.20) {
                // é­š (20%)
                this.enemies.push(new Fish(this.width, Math.random() * (this.height - 100) + 50));
            } else if (type < 0.35) {
                // ã‚¤ãƒ¯ã‚·ã®ç¾¤ã‚Œ (15%)
                const baseY = Math.random() * (this.height - 150) + 50;
                const count = Math.floor(Math.random() * 6) + 10; // 10~15åŒ¹
                for(let i=0; i<count; i++) {
                    this.enemies.push(new Sardine(this.width + Math.random() * 200, baseY + Math.random()*80 - 40));
                }
            } else if (type < 0.45) {
                // ãƒã‚°ãƒ­ (10%) - ç›´é€²é«˜é€Ÿ
                this.enemies.push(new Tuna(this.width, Math.random() * (this.height - 100) + 50));
            } else if (type < 0.50) {
                // ã‚µãƒ¡ (5%) - ãƒ›ãƒ¼ãƒŸãƒ³ã‚°
                this.enemies.push(new Shark(this.width, Math.random() * (this.height - 100) + 50, this.player));
            } else if (type < 0.60) {
                // ç¶² (10%)
                this.enemies.push(new Net(this.width, Math.random() * (this.height - 200) + 100));
            } else if (type < 0.70) {
                // é‡£ã‚Šé‡ (10%)
                this.enemies.push(new Hook(this.width, -100));
            } else if (type < 0.80) {
                // ã‚¤ã‚« (10%)
                this.enemies.push(new Squid(this.width, Math.random() * (this.height - 200) + 100));
            } else if (type < 0.90) {
                // ã‚¿ã‚³ (5%) - æ–°è¦
                this.enemies.push(new Octopus(this.width, Math.random() * (this.height - 200) + 100));
            } else if (type < 0.93) {
                // ãƒãƒªã‚»ãƒ³ãƒœãƒ³ (5%) - æ–°è¦
                this.enemies.push(new Porcupinefish(this.width, Math.random() * (this.height - 100) + 50, this));
            } else if (type < 0.96) {
                // ã†ãšã—ãŠ (3%) - ç”»é¢ä¸Šéƒ¨ã«å‡ºç¾
                this.enemies.push(new Whirlpool(this.width, Math.random() * 80 + 40));
            } else if (type < 0.98) {
                // æ½œã‚€é­š (3%) - æµ·åº•ã«å‡ºç¾
                this.enemies.push(new Flatfish(this.width, this.height - 40));
            } else {
                // ã†ã« (2%) - æµ·åº•ã«é…ç½®
                this.enemies.push(new SeaUrchin(this.width, this.height - 65));
            }
        }
    }

    showLevelUp() {
        this.uiLevelUp.classList.remove('animate');
        // Trigger reflow
        void this.uiLevelUp.offsetWidth;
        this.uiLevelUp.classList.add('animate');
    }

    spawnDecorations() {
        const groundY = this.getGroundY(this.width);

        // æµ·åº•ã®è£…é£¾ (ã‚ã‹ã‚ã€å²©ã€ã‚µãƒ³ã‚´)
        if (this.frameCount % 30 === 0) { // å²©ã‚¾ãƒ¼ãƒ³ã®ãŸã‚ã«å°‘ã—é »åº¦ã‚’æˆ»ã™
            const rand = Math.random();
            if (rand < 0.6) {
                this.decorations.push(new Seaweed(this.width, groundY));
                // ã‚ã‹ã‚ã«æ··ã˜ã£ã¦ãƒãƒ³ã‚¢ãƒŠã‚´
                if (Math.random() < 0.1) { // å‡ºç¾ç‡ã‚’ä¸‹ã’ã‚‹
                    this.items.push(new GardenEel(this.width + 20, groundY));
                }
            } else if (rand < 0.85) { // å²©ã®ç¢ºç‡ã‚’å°‘ã—ä¸Šã’ã‚‹
                this.decorations.push(new RuggedTerrain(this.width, this.height));
            } else {
                this.decorations.push(new Coral(this.width, groundY));
                // ã‚µãƒ³ã‚´ç¤ã«ã‚«ã‚¯ãƒ¬ã‚¯ãƒãƒãƒŸ
                if (Math.random() < 0.5) {
                    this.items.push(new Clownfish(this.width, this.height - 80));
                }
            }
        }
        // ãƒ‘ãƒ¼ãƒ« (ãŸã¾ã«)
        if (this.frameCount % 300 === 0) {
            // æµ·åº•ã«é…ç½®
            this.items.push(new Pearl(this.width, groundY - 15));
        }
        // ãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³ (é »ç¹ã«)
        if (this.frameCount % 100 === 0) {
            this.items.push(new Plankton(this.width, Math.random() * (this.height - 100) + 50));
        }
        // ä»²é–“ã‚¨ãƒ“ (ãƒ¬ã‚¢)
        if (this.frameCount % 600 === 0) {
            this.items.push(new FriendShrimp(this.width, Math.random() * (this.height - 100) + 50));
        }
    }

    scatterItems(x, y) {
        // å¤§é‡ã®ãƒ‘ãƒ¼ãƒ«ï¼ˆé‡åŠ›ã§è½ã¡ã‚‹ï¼‰
        for(let k=0; k<8; k++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 6 + 2;
            this.items.push(new Pearl(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed));
        }
        // å¤§é‡ã®ãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³ï¼ˆãµã‚ãµã‚åºƒãŒã‚‹ï¼‰
        for(let k=0; k<15; k++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 6 + 2;
            this.items.push(new Plankton(x, y, Math.cos(angle)*speed, Math.sin(angle)*speed));
        }
    }

    recordState() {
        // 2ãƒ•ãƒ¬ãƒ¼ãƒ ã«1å›è¨˜éŒ²
        if (this.frameCount % 2 !== 0) return;

        const snapshot = {
            player: {
                x: this.player.x, y: this.player.y, 
                angle: this.player.angle, isBending: this.player.isBending,
                lives: this.lives
            },
            scrollOffset: this.scrollOffset,
            score: this.score,
            objects: [],
            decorations: [] // å²©ã®åˆ¤å®šç”¨ã«åˆ¥é€”ä¿å­˜
        };

        // æç”»ã«å¿…è¦ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŠ¶æ…‹ã‚’ä¿å­˜
        const saveObj = (obj) => {
            const data = {
                type: obj.constructor.name,
                x: obj.x, y: obj.y,
                // å„ã‚¯ãƒ©ã‚¹å›ºæœ‰ã®æç”»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                angle: obj.angle,
                timer: obj.timer,
                moveTimer: obj.moveTimer,
                hasExploded: obj.hasExploded,
                width: obj.width, height: obj.height, // Rock, Seaweed
                color: obj.color, // Rock, Coral
                branches: obj.branches, // Coral
                life: obj.life, size: obj.size, isBackground: obj.isBackground, // Bubble
                length: obj.length // StreamLine
            };
            snapshot.objects.push(data);
        };

        this.decorations.forEach(saveObj);
        this.items.forEach(saveObj);
        this.enemies.forEach(saveObj);
        this.particles.forEach(saveObj);
        this.streamLines.forEach(saveObj);
        snapshot.decorations = this.decorations.map(d => ({ type: d.constructor.name, x: d.x, y: d.y, width: d.width, height: d.height }));

        this.replayBuffer.push(snapshot);
        // ãƒãƒƒãƒ•ã‚¡åˆ¶é™ï¼ˆç´„10ç§’åˆ† = 30fps * 10s = 300ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
        if (this.replayBuffer.length > 300) {
            this.replayBuffer.shift();
        }
    }

    update() {
        if (this.state === STATE.REPLAY) {
            this.replayIndex++;
            if (this.replayIndex >= this.replayBuffer.length) {
                // ãƒªãƒ—ãƒ¬ã‚¤çµ‚äº†
                this.gameOver(this.deathReason);
            }
            return;
        }

        if (this.state !== STATE.PLAYING) {
            if (this.state === STATE.GAMEOVER) this.frameCount++;
            return;
        }

        this.frameCount++;
        this.score += 0.1; // è·é›¢åŠ ç®—
        this.scrollOffset += this.scrollSpeed;
        this.uiScore.innerText = Math.floor(this.score);

        // çŠ¶æ…‹è¨˜éŒ²ï¼ˆãƒªãƒ—ãƒ¬ã‚¤ç”¨ï¼‰
        this.recordState();

        // BGMãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ›´æ–°
        this.sound.setBGMParams(this.score);

        // ãƒœã‚¹å‡ºç¾åˆ¤å®š
        if (this.score - this.lastBossDistance >= CONSTANTS.BOSS_INTERVAL) {
            this.lastBossDistance = Math.floor(this.score);
            // è­¦å‘Šè¡¨ç¤º
            this.uiWarning.classList.add('active');
            
            // 3ç§’å¾Œã«ãƒœã‚¹å‡ºç¾
            setTimeout(() => {
                this.uiWarning.classList.remove('active');
                if (this.state === STATE.PLAYING) {
                    this.enemies.push(new Whale(this.width, this.height / 2));
                }
            }, 3000);
        }

        // ãƒ’ãƒ©ãƒ¡æ¼”å‡ºä¸­ã¯æ›´æ–°åœæ­¢ï¼ˆæ¼”å‡ºç”¨ã‚¿ã‚¤ãƒãƒ¼ã®ã¿å‹•ã‹ã™ï¼‰
        if (this.state === STATE.BITTEN) return;

        // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—åˆ¤å®š (100mã”ã¨)
        const currentLevel = Math.floor(this.score / 100);
        if (currentLevel > this.level) {
            this.level = currentLevel;
            this.uiLevel.innerText = this.level + 1;
            this.scrollSpeed += 0.5; // é€Ÿåº¦ã‚¢ãƒƒãƒ—
            this.showLevelUp();
        }

        // æ¿€æµã‚¾ãƒ¼ãƒ³ã®åˆ¶å¾¡
        this.rapidCurrentTimer++;
        // ç´„20ç§’ã”ã¨ã«5ç§’é–“æ¿€æµã«ã™ã‚‹
        // é›£æ˜“åº¦ãŒé«˜ã„ã»ã©é »ç¹ã«
        const rapidCurrentInterval = this.difficulty === 'HARD' ? 800 : 1200;
        if (!this.isRapidCurrent && this.rapidCurrentTimer > rapidCurrentInterval) {
            if (Math.random() < 0.02) { // ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’æŒãŸã›ã‚‹
                this.isRapidCurrent = true;
                this.rapidCurrentTimer = 0;
                this.addFloatingText(this.width / 2, this.height / 2, "æ¿€æµæ³¨æ„ï¼", "#FF4500");
            }
        } else if (this.isRapidCurrent) {
            if (this.rapidCurrentTimer > 300) {
                this.isRapidCurrent = false;
                this.rapidCurrentTimer = 0;
            }
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å·¦ã«æŠ¼ã—æµã™åŠ›
            this.player.vx -= 0.15;
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°
        this.player.update(this);

        // ç”»é¢å·¦ç«¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
        if (this.player.x < -this.player.radius) {
            this.lives = 0;
            this.gameOver("æ³¢ã«é£²ã¾ã‚ŒãŸ"); // ç„¡æ•µæ™‚é–“ã‚’ç„¡è¦–ã—ã¦å³ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
            return;
        }

        // æ•µç”Ÿæˆã¨æ›´æ–°
        this.spawnEnemy();
        this.spawnDecorations();
        
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            enemy.update(this.scrollSpeed, this); // Hookã®ãŸã‚ã«this(game)ã‚’æ¸¡ã™

            // å®‰å…¨ç­–: åº§æ¨™ãŒNaNã«ãªã£ãŸæ•µã¯å‰Šé™¤ï¼ˆãƒ•ãƒªãƒ¼ã‚ºé˜²æ­¢ï¼‰
            if (!isFinite(enemy.x) || !isFinite(enemy.y)) {
                this.enemies.splice(i, 1);
                continue;
            }

            // ç”»é¢å¤–åˆ¤å®š
            if (enemy.isOffScreen(this.width, this.height)) {
                this.enemies.splice(i, 1);
                continue;
            }

            // å½“ãŸã‚Šåˆ¤å®š
            if (enemy.checkCollision(this.player)) {
                if (enemy instanceof Flatfish) {
                    // ãƒ’ãƒ©ãƒ¡ã¯å³æ­»æ¼”å‡º
                    this.triggerFlatfishDeath(enemy);
                } else {
                    let reason = "æ•µã«ã¶ã¤ã‹ã£ãŸ";
                    if (enemy instanceof Fish) reason = "é­šã«ã¶ã¤ã‹ã£ãŸ";
                    else if (enemy instanceof Sardine) reason = "ã‚¤ãƒ¯ã‚·ã®ç¾¤ã‚Œã«å·»ãè¾¼ã¾ã‚ŒãŸ";
                    else if (enemy instanceof Tuna) reason = "ãƒã‚°ãƒ­ã«æ¿€çªã•ã‚ŒãŸ";
                    else if (enemy instanceof Hook) reason = "é‡£ã‚Šé‡ã«å¼•ã£ã‹ã‹ã£ãŸ";
                    else if (enemy instanceof Anglerfish) reason = "æç¯é®Ÿé±‡ã«é£Ÿã¹ã‚‰ã‚ŒãŸ";
                    else if (enemy instanceof Shark) reason = "ã‚µãƒ¡ã«å™›ã¾ã‚ŒãŸ";
                    else if (enemy instanceof Net) reason = "ç¶²ã«æ•ã¾ã£ãŸ";
                    else if (enemy instanceof Squid) reason = "ã‚¤ã‚«ã«ã¶ã¤ã‹ã£ãŸ";
                    else if (enemy instanceof Octopus) reason = "ã‚¿ã‚³ã«æ•ã¾ã£ãŸ";
                    else if (enemy instanceof Porcupinefish || enemy instanceof Needle) reason = "ãƒãƒªã‚»ãƒ³ãƒœãƒ³ã®é‡ãŒåˆºã•ã£ãŸ";
                    else if (enemy instanceof Whirlpool) reason = "ã†ãšã—ãŠã«å·»ãè¾¼ã¾ã‚ŒãŸ";
                    else if (enemy instanceof Whale) reason = "å·¨å¤§ã‚¯ã‚¸ãƒ©ã«è¡çªã—ãŸ";
                    else if (enemy instanceof SeaUrchin) reason = "ã†ã«ã«åˆºã•ã£ãŸ";
                    this.hitPlayer(reason);
                }
            }
        }

        // ã‚¢ã‚¤ãƒ†ãƒ æ›´æ–°
        for (let i = this.items.length - 1; i >= 0; i--) {
            const item = this.items[i];
            item.update(this.scrollSpeed, this); // gameã‚’æ¸¡ã™
            
            // å®‰å…¨ç­–
            if (!isFinite(item.x) || !isFinite(item.y)) {
                this.items.splice(i, 1);
                continue;
            }

            if (item.isOffScreen(this.width, this.height)) {
                this.items.splice(i, 1);
                continue;
            }
            
            if (item.checkCollision(this.player)) {
                this.sound.playItem();
                if (item instanceof Pearl) {
                    this.score += 50;
                    this.addFloatingText(item.x, item.y, "+50", "#FFD700");
                } else if (item instanceof FriendShrimp) { // Planktonã‚ˆã‚Šå…ˆã«åˆ¤å®šã™ã‚‹
                    if (this.lives < CONSTANTS.MAX_LIVES) {
                        this.lives++;
                        this.updateLifeDisplay();
                        this.updatePlayerSize();
                        this.addFloatingText(item.x, item.y, "1UP!", "#FF69B4");
                    } else {
                        // ãƒ©ã‚¤ãƒ•æº€ã‚¿ãƒ³ãªã‚‰ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒŠã‚¹
                        this.score += 100;
                        this.addFloatingText(item.x, item.y, "+100", "#FFD700");
                    }
                } else if (item instanceof Plankton) {
                    this.score += 10;
                    this.addFloatingText(item.x, item.y, "+10", "#90EE90");
                } else if (item instanceof Clownfish) {
                    this.score += 50;
                    this.addFloatingText(item.x, item.y, "+50", "#FF4500");
                } else if (item instanceof GardenEel) {
                    this.score += 30;
                    this.addFloatingText(item.x, item.y, "+30", "#FFFFFF");
                }
                this.items.splice(i, 1);
            }
        }

        // è£…é£¾æ›´æ–°
        for (let i = this.decorations.length - 1; i >= 0; i--) {
            const deco = this.decorations[i];
            deco.update(this.scrollSpeed, this);
            
            // ç”»é¢å¤–åˆ¤å®šä¿®æ­£: å²©ãªã©ãŒå®Œå…¨ã«æ¶ˆãˆã¦ã‹ã‚‰å‰Šé™¤
            if (deco.x < -200) this.decorations.splice(i, 1);

            // æ–°ã—ã„å²©ï¼ˆåœ°å½¢ï¼‰ã®å½“ãŸã‚Šåˆ¤å®š
            if (deco instanceof RuggedTerrain) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒãŒå²©ã®æœ€é«˜ç‚¹ã‚ˆã‚Šä¸‹ã®å ´åˆã®ã¿ã€æ¨ªã‹ã‚‰ã®è¡çªã‚’åˆ¤å®š
                // ã“ã‚Œã«ã‚ˆã‚Šã€ä¸Šã‹ã‚‰ä¹—ã‚ã†ã¨ã—ãŸã¨ãã«æŠ¼ã—å‡ºã•ã‚Œã‚‹ã®ã‚’é˜²ã
                const highestPoint = Math.min(...deco.points.map(p => p.y));
                if (this.player.y > highestPoint && deco.checkSideCollision(this.player)) {
                     this.player.x = deco.x - this.player.radius;
                     if (this.player.vx > 0) this.player.vx = 0;
                }
            }
        }

        // æ¿€æµã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ©ã‚¤ãƒ³ï¼‰
        if (this.isRapidCurrent && this.frameCount % 5 === 0) {
            this.streamLines.push(new StreamLine(this.width, Math.random() * this.height));
        }
        for (let i = this.streamLines.length - 1; i >= 0; i--) {
            // æ¿€æµæ™‚ã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚‚é€Ÿãè¦‹ãˆã‚‹ã‚ˆã†ã«
            this.streamLines[i].update(this.scrollSpeed + 10);
            if (this.streamLines[i].x < -200) this.streamLines.splice(i, 1);
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆæ³¡ï¼‰
        if (this.frameCount % 20 === 0) {
            this.particles.push(new Bubble(this.player.x, this.player.y));
            if (Math.random() < 0.05) this.sound.playBubble(); // ãŸã¾ã«éŸ³ã‚’é³´ã‚‰ã™
        }

        // èƒŒæ™¯ã®æ³¡ï¼ˆã‚¹ã‚³ã‚¢ã«å¿œã˜ã¦å¢—ãˆã‚‹æ¼”å‡ºï¼‰
        // æ·±åº¦(score)ã«å¿œã˜ã¦ç™ºç”Ÿç¢ºç‡ã¨æ•°ã‚’ä¸Šã’ã‚‹
        const bubbleDensity = Math.min(20, Math.floor(this.score / 300)); 
        if (this.frameCount % 15 === 0) {
            // åŸºæœ¬ç¢ºç‡ + ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒŠã‚¹
            if (Math.random() < 0.2 + (bubbleDensity * 0.05)) {
                // ç”»é¢ä¸‹éƒ¨ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«ç™ºç”Ÿ
                this.particles.push(new Bubble(Math.random() * (this.width + 100), this.height + 10, true));
            }
        }

        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update(this.scrollSpeed);
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
        for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
            this.floatingTexts[i].update();
            if (this.floatingTexts[i].life <= 0) this.floatingTexts.splice(i, 1);
        }
    }

    draw() {
        if (this.state === STATE.REPLAY) {
            this.drawReplay();
            return;
        }

        // ãƒ’ãƒ©ãƒ¡æ•é£Ÿæ¼”å‡ºä¸­ã®æç”»
        if (this.state === STATE.BITTEN) {
            this.bittenTimer++;
            
            // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯æ¼”å‡º
            const shakeX = (Math.random() - 0.5) * 20;
            const shakeY = (Math.random() - 0.5) * 20;
            this.ctx.save();
            this.ctx.translate(shakeX, shakeY);

            // èƒŒæ™¯ãªã©ã¯ãã®ã¾ã¾
            // ãƒ’ãƒ©ãƒ¡ã‚’æç”»ï¼ˆå£ã‚’é–‰ã˜ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã©ï¼‰
            this.killerEnemy.draw(this.ctx, true); // true = æ•é£Ÿä¸­
            
            this.ctx.restore();

            // ä¸€å®šæ™‚é–“å¾Œã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
            if (this.bittenTimer > 60) {
                this.gameOver();
            }
            return;
        }

        // èƒŒæ™¯ã‚¯ãƒªã‚¢
        // ã‚¹ã‚³ã‚¢ã«å¿œã˜ã¦èƒŒæ™¯è‰²ã‚’æ·±æµ·ï¼ˆæš—ãï¼‰ã«ã™ã‚‹æ¼”å‡º
        const maxDepth = 2000; // 2000mã§æœ€ã‚‚æš—ããªã‚‹
        const ratio = Math.min(this.score / maxDepth, 1);
        
        // #87CEEB (135, 206, 235) -> #001020 (0, 16, 32)
        const r = Math.floor(135 * (1 - ratio) + 0 * ratio);
        const g = Math.floor(206 * (1 - ratio) + 16 * ratio);
        const b = Math.floor(235 * (1 - ratio) + 32 * ratio);

        // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ (ä¸Šã‹ã‚‰å…‰ãŒå·®ã—è¾¼ã‚€è¡¨ç¾)
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
        gradient.addColorStop(0, `rgb(${Math.min(255, r+30)},${Math.min(255, g+30)},${Math.min(255, b+30)})`);
        gradient.addColorStop(1, `rgb(${r},${g},${b})`);
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.width, this.height);

        // æµ·åº•ã®æç”»ï¼ˆç ‚ï¼‰
        // ã†ã­ã†ã­ã•ã›ã‚‹
        this.ctx.fillStyle = '#E0C090'; // ç ‚ã£ã½ã„è‰²
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.height);
        for (let x = 0; x <= this.width; x += 10) {
            this.ctx.lineTo(x, this.getGroundY(x));
        }
        this.ctx.lineTo(this.width, this.height);
        this.ctx.fill();

        // æ¿€æµã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»
        this.streamLines.forEach(l => l.draw(this.ctx));

        // ã‚¢ã‚¤ãƒ†ãƒ æç”»
        this.items.forEach(i => i.draw(this.ctx));

        // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆæç”»
        this.floatingTexts.forEach(t => t.draw(this.ctx));

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»
        this.particles.forEach(p => p.draw(this.ctx));

        // æ•µæç”»
        this.enemies.forEach(e => e.draw(this.ctx));

        // è£…é£¾æç”»
        this.decorations.forEach(d => d.draw(this.ctx, this.frameCount));

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
        this.player.draw(this.ctx, this.lives, this.decorations);
    }

    drawReplay() {
        const snapshot = this.replayBuffer[this.replayIndex];
        if (!snapshot) return;

        // èƒŒæ™¯æç”»ï¼ˆå…±é€šå‡¦ç†ã®ä¸€éƒ¨å†åˆ©ç”¨ï¼‰
        const maxDepth = 2000;
        const ratio = Math.min(snapshot.score / maxDepth, 1);
        const r = Math.floor(135 * (1 - ratio) + 0 * ratio);
        const g = Math.floor(206 * (1 - ratio) + 16 * ratio);
        const b = Math.floor(235 * (1 - ratio) + 32 * ratio);
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
        gradient.addColorStop(0, `rgb(${Math.min(255, r+30)},${Math.min(255, g+30)},${Math.min(255, b+30)})`);
        gradient.addColorStop(1, `rgb(${r},${g},${b})`);
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.width, this.height);

        // åœ°é¢
        this.ctx.fillStyle = '#E0C090';
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.height);
        // åœ°é¢ã®ã†ã­ã‚Šã¯scrollOffsetã«ä¾å­˜ã™ã‚‹ãŸã‚ã€snapshotã®å€¤ã‚’ä½¿ç”¨
        const getGroundY = (x) => {
            const base = this.height - 50;
            return base + Math.sin((x + snapshot.scrollOffset) * 0.005) * 20 + Math.sin((x + snapshot.scrollOffset) * 0.02) * 10;
        };
        for (let x = 0; x <= this.width; x += 10) {
            this.ctx.lineTo(x, getGroundY(x));
        }
        this.ctx.lineTo(this.width, this.height);
        this.ctx.fill();

        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»
        snapshot.objects.forEach(data => {
            const dummy = this.replayDummies[data.type];
            if (dummy) {
                Object.assign(dummy, data); // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ã‚³ãƒ”ãƒ¼
                dummy.draw(this.ctx, this.frameCount); // frameCountã¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã ãŒã€ãƒªãƒ—ãƒ¬ã‚¤ã§ã¯é€²è¡Œã—ç¶šã‘ã‚‹å€¤ã§ä»£ç”¨
            }
        });

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
        const pData = snapshot.player;
        const pDummy = this.replayDummies['Shrimp'];
        Object.assign(pDummy, pData);
        
        // ä»²é–“ã‚¨ãƒ“ã®æç”»ï¼ˆå±¥æ­´ã‹ã‚‰å¾©å…ƒï¼‰
        // ãƒªãƒ—ãƒ¬ã‚¤ãƒãƒƒãƒ•ã‚¡è‡ªä½“ã‚’å±¥æ­´ã¨ã—ã¦ä½¿ã†
        const followerCount = Math.max(0, pData.lives - 1);

        for (let i = 1; i <= followerCount; i++) {
            // 2ãƒ•ãƒ¬ãƒ¼ãƒ ã«1å›è¨˜éŒ²ã—ã¦ã„ã‚‹ã®ã§ã€é…å»¶ãƒ•ãƒ¬ãƒ¼ãƒ æ•°(8) / 2 = 4ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å‰ã‚’å‚ç…§
            const delayIdx = i * 4;
            const prevSnapshot = this.replayBuffer[this.replayIndex - delayIdx];
            if (prevSnapshot) pDummy.drawFollower(this.ctx, prevSnapshot.player);
        }
        // æœ¬ä½“æç”»
        Object.assign(pDummy, pData); // æˆ»ã™
        pDummy.draw(this.ctx, pData.lives, snapshot.decorations.map(d => Object.assign(this.replayDummies[d.type], d)));

        // UI
        this.ctx.fillStyle = 'white';
        this.ctx.font = '20px sans-serif';
        this.ctx.fillText("REPLAY", 20, 80);
    }
    
    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

/**
 * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹: ãˆã³ã¡ã‚ƒã‚“
 */
class Shrimp {
    constructor(x, y) {
        this.reset(x, y);
        this.radius = CONSTANTS.SHRIMP_BASE_SIZE;
    }

    reset(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.angle = 0;
        this.isBending = false; // ãã®å­—çŠ¶æ…‹
        this.invincibleTimer = 0;
        this.bendTimer = 0;
        this.history = []; // è»Œè·¡ä¿å­˜ç”¨
        this.recoveryBoostTimer = 0;
    }

    jump() {
        // ä»•æ§˜: å¾Œæ–¹ï¼‹ä¸Šæ–¹å‘ã¸è·³ã­ã‚‹
        this.vy = CONSTANTS.JUMP_FORCE_Y;
        this.vx = CONSTANTS.JUMP_FORCE_X;
        this.isBending = true;
        this.bendTimer = 15; // å¤‰å½¢æŒç¶šãƒ•ãƒ¬ãƒ¼ãƒ 
        this.recoveryBoostTimer = 30; // æ³³ããƒ–ãƒ¼ã‚¹ãƒˆ
    }

    setInvincible(frames) {
        this.invincibleTimer = frames;
    }

    update(game) {
        const screenWidth = game.width;

        // é‡åŠ›ï¼ˆå¾ã€…ã«æ²ˆã‚€ï¼‰
        this.vy += CONSTANTS.GRAVITY;

        if (this.recoveryBoostTimer > 0) this.recoveryBoostTimer--;
        const recoveryForce = (this.recoveryBoostTimer > 0) ? 0.35 : 0.2;
        
        // è‡ªå‹•å‰é€²ï¼ˆå…ƒã®ä½ç½®ã«æˆ»ã‚ã†ã¨ã™ã‚‹åŠ›ï¼‰
        // ç”»é¢å·¦ç«¯ã«è¡Œãéããªã„ã‚ˆã†ã«ã€å³æ–¹å‘ã¸ä¸€å®šã®åŠ›ã‚’ã‹ã‘ã‚‹
        if (this.x < this.radius * 4) {
            this.vx -= 0.5; // å·¦ç«¯ã«è¿‘ã¥ãã¨å¤–å´ã«å¸ã„è¾¼ã¾ã‚Œã‚‹ï¼ˆå¾©å¸°å›°é›£ã«ï¼‰
        } else if (this.x < screenWidth * 0.3) {
            this.vx += recoveryForce; // é ‘å¼µã£ã¦æ³³ãã¨å¾©å¸°åŠ›ã‚¢ãƒƒãƒ—
        } else {
            // å®šä½ç½®ã‚ˆã‚Šå‰ã«å‡ºéããªã„ã‚ˆã†ã«æ¸›é€Ÿ
            this.vx *= 0.95;
        }

        // é€Ÿåº¦é©ç”¨
        this.x += this.vx;
        this.y += this.vy;

        // ç”»é¢ç«¯åˆ¶é™
        // å¤©äº•
        if (this.y < this.radius) { this.y = this.radius; this.vy = 0; } // å¤©äº•
        
        // åœ°é¢ï¼ˆæµ·åº•ãƒ»å²©ï¼‰ã¨ã®å½“ãŸã‚Šåˆ¤å®š
        let groundY = game.getGroundY(this.x);
        for (const deco of game.decorations.filter(d => d instanceof RuggedTerrain)) {
            if (this.x > deco.x && this.x < deco.x + deco.width) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çœŸä¸‹ã®å²©ã®è¡¨é¢Yåº§æ¨™ã‚’å–å¾—
                const rockSurfaceY = deco.getSurfaceY(this.x);
                if (rockSurfaceY < groundY) {
                    groundY = rockSurfaceY;
                }
            }
            // æ¨ªã‹ã‚‰ã®è¡çªåˆ¤å®š
            else if (deco.checkSideCollision(this)) {
                this.x = deco.x - this.radius;
                if (this.vx > 0) this.vx = 0;
            }
        }
        if (this.y > groundY - this.radius) { // åœ°é¢ã«ç€åœ°
            this.y = groundY - this.radius;
            this.vy = 0;
        }
        
        // å³å£
        if (this.x > screenWidth - this.radius) this.x = screenWidth - this.radius; // å³å£

        // å¤‰å½¢ã‚¿ã‚¤ãƒãƒ¼
        if (this.bendTimer > 0) {
            this.bendTimer--;
        } else {
            this.isBending = false;
        }

        // NaNã‚¬ãƒ¼ãƒ‰
        if (isNaN(this.x)) { this.x = 100; this.vx = 0; }
        if (isNaN(this.y)) { this.y = 100; this.vy = 0; }
        if (isNaN(this.vx)) this.vx = 0;
        if (isNaN(this.vy)) this.vy = 0;

        // å±¥æ­´ã®æ›´æ–°ï¼ˆè¿½å¾“ç”¨ï¼‰
        this.history.unshift({x: this.x, y: this.y, angle: this.angle, isBending: this.isBending});
        if (this.history.length > 100) {
            this.history.pop();
        }
        
        if (this.invincibleTimer > 0) {
            this.invincibleTimer--;
        }

        // è§’åº¦è¨ˆç®—ï¼ˆé€²è¡Œæ–¹å‘ã«å‘ã‘ã‚‹ï¼‰
        // ãƒãƒƒã‚¯ä¸­ã¯å¾Œã‚å‘ãã€é€šå¸¸ã¯å‰å‘ã
        if (this.isBending) {
            this.angle = -Math.PI / 4; // ãƒãƒƒã‚¯æ™‚ã®è§’åº¦
        } else {
            this.angle = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, this.vy * 0.1));
        }
    }
    
    get isInvincible() {
        return this.invincibleTimer > 0;
    }

    draw(ctx, lives = 1, decorations = []) {
        // ç„¡æ•µæ™‚é–“ã¯ç‚¹æ»…
        if (this.isInvincible && Math.floor(Date.now() / 100) % 2 === 0) return;

        // ä»²é–“ï¼ˆæ®‹æ©Ÿåˆ†ï¼‰ã®æç”»
        // å±¥æ­´ã‚’ä½¿ã£ã¦å¾Œã‚ã‚’ã¤ã„ã¦ã“ã•ã›ã‚‹
        // 1åŒ¹ã‚ãŸã‚Š10ãƒ•ãƒ¬ãƒ¼ãƒ é…ã‚Œã§è¡¨ç¤º
        const followerCount = Math.max(0, lives - 1);
        for (let i = 1; i <= followerCount; i++) {
            const delay = i * 8;
            if (this.history[delay]) {
                const pos = this.history[delay];
                // å®‰å…¨ç­–: å±¥æ­´ãŒä¸æ­£ãªå ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                const followerDummy = { x: pos.x, y: pos.y, radius: this.radius * 0.7 };
                let inRock = false;
                if (decorations) {
                    inRock = decorations.some(d => d instanceof RuggedTerrain && d.checkSideCollision(followerDummy));
                }

                if (inRock) continue;

                if (!isFinite(pos.x) || !isFinite(pos.y)) continue;
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.angle);
                // ä»²é–“ã¯å°‘ã—å°ã•ãã€è‰²ã‚’å¤‰ãˆã‚‹
                const scale = 0.7;
                ctx.scale(scale, scale);
                // ä»²é–“ã®è‰²
                const fGrad = ctx.createRadialGradient(0, -this.radius*0.2, 0, 0, 0, this.radius);
                fGrad.addColorStop(0, '#FFC0CB');
                fGrad.addColorStop(1, '#FFB6C1');
                ctx.fillStyle = fGrad;
                this.drawBody(ctx, pos.isBending);
                ctx.restore();
            }
        }

        // å®‰å…¨ç­–
        if (!isFinite(this.x) || !isFinite(this.y)) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const grad = ctx.createRadialGradient(0, -this.radius*0.2, 0, 0, 0, this.radius);
        grad.addColorStop(0, '#FF8E84');
        grad.addColorStop(1, CONSTANTS.SHRIMP_COLOR);
        ctx.fillStyle = grad;
        
        this.drawBody(ctx, this.isBending);

        ctx.restore();
    }

    drawFollower(ctx, pos) {
        if (!isFinite(pos.x) || !isFinite(pos.y)) return;
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(pos.angle);
        // ä»²é–“ã¯å°‘ã—å°ã•ãã€è‰²ã‚’å¤‰ãˆã‚‹
        const scale = 0.7;
        ctx.scale(scale, scale);
        // ä»²é–“ã®è‰²
        const fGrad = ctx.createRadialGradient(0, -this.radius*0.2, 0, 0, 0, this.radius);
        fGrad.addColorStop(0, '#FFC0CB');
        fGrad.addColorStop(1, '#FFB6C1');
        ctx.fillStyle = fGrad;
        this.drawBody(ctx, pos.isBending);
        ctx.restore();
    }

    drawBody(ctx, isBending) {
        const baseStyle = ctx.fillStyle;
        // ã‚ˆã‚Šãƒªã‚¢ãƒ«ã§ã‚¹ã‚¿ã‚¤ãƒªãƒƒã‚·ãƒ¥ãªã‚¨ãƒ“ã®ãƒ‡ã‚¶ã‚¤ãƒ³
        if (isBending) {
            // ãã®å­—ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—æ™‚ï¼‰
            ctx.beginPath();
            // èƒ´ä½“ï¼ˆæ›²ãŒã£ã¦ã„ã‚‹ï¼‰
            ctx.ellipse(0, 0, this.radius * 1.2, this.radius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å°»å°¾
            ctx.beginPath();
            ctx.moveTo(-this.radius * 0.8, 0);
            ctx.lineTo(-this.radius * 1.8, this.radius * 0.6);
            ctx.lineTo(-this.radius * 1.4, -this.radius * 0.2);
            ctx.fill();
        } else {
            // é€šå¸¸ï¼ˆä¼¸ã³ã¦ã„ã‚‹ï¼‰
            ctx.beginPath();
            // èƒ´ä½“
            ctx.ellipse(0, 0, this.radius * 1.6, this.radius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ç¯€ï¼ˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼‰ã®è¡¨ç¾
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for(let i=0; i<3; i++) {
                ctx.beginPath();
                ctx.arc(-this.radius * 0.5 + i * this.radius * 0.5, -this.radius * 0.2, this.radius * 0.4, 0, Math.PI, false);
                ctx.fill();
            }
            ctx.fillStyle = baseStyle;

            // è¶³
            ctx.strokeStyle = baseStyle;
            ctx.lineWidth = 2;
            for(let i=0; i<4; i++) {
                ctx.beginPath();
                const x = -this.radius * 0.5 + i * this.radius * 0.4;
                ctx.moveTo(x, this.radius * 0.3);
                ctx.lineTo(x - 2, this.radius * 0.8);
                ctx.stroke();
            }

            // å°»å°¾
            ctx.beginPath();
            ctx.moveTo(-this.radius, 0);
            ctx.lineTo(-this.radius * 1.75, this.radius * 0.25);
            ctx.lineTo(-this.radius * 1.75, -this.radius * 0.25);
            ctx.fill();
        }

        // é•·ã„è§¦è§’
        ctx.strokeStyle = '#FF4500';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.radius, -5);
        ctx.quadraticCurveTo(this.radius + 20, -20, this.radius + 10, -30);
        ctx.moveTo(this.radius, -5);
        ctx.quadraticCurveTo(this.radius + 25, -15, this.radius + 15, -35);
        ctx.stroke();

        // ç›®ï¼ˆã‹ã‚ã„ã•é‡è¦–ï¼‰
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.radius * 0.8, -5, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.radius * 0.9, -5, 2, 0, Math.PI * 2);
        ctx.fill();
        // ç›®ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.radius * 0.9 - 1, -5 - 1, 1, 0, Math.PI * 2);
        ctx.fill();
    }
}

/**
 * æ•µã‚¯ãƒ©ã‚¹ç¾¤
 */
class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.markedForDeletion = false;
    }
    update(speed) { this.x -= speed; }
    draw(ctx) {}
    isOffScreen(w, h) { return this.x < -100 || this.y > h + 100; }
    checkCollision(player) {
        // ç°¡æ˜“å††å½¢å½“ãŸã‚Šåˆ¤å®š
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (this.radius + player.radius);
    }
}

class Fish extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 15;
        this.extraSpeed = Math.random() * 2;
        this.angle = Math.random() * Math.PI * 2;
    }
    update(baseSpeed) { 
        this.x -= (baseSpeed + this.extraSpeed);
        // å‹•ãã‚’å·¥å¤«: ä¸Šä¸‹ã«ã‚†ã‚‰ã‚†ã‚‰æºã‚Œã‚‹
        this.y += Math.sin(this.angle += 0.05) * 1.5;
    }
    draw(ctx) {
        // å·¦å‘ã
        const grad = ctx.createLinearGradient(this.x + 25, this.y - 15, this.x - 25, this.y + 15);
        grad.addColorStop(0, '#5F9EA0');
        grad.addColorStop(1, '#4682B4');
        ctx.fillStyle = grad;
        
        // ä½“ï¼ˆæµç·šå‹ï¼‰
        ctx.beginPath();
        ctx.moveTo(this.x - 25, this.y); // é ­ï¼ˆå·¦ï¼‰
        ctx.quadraticCurveTo(this.x, this.y - 20, this.x + 25, this.y); // èƒŒä¸­
        ctx.quadraticCurveTo(this.x, this.y + 20, this.x - 25, this.y); // è…¹
        ctx.fill();
        
        // é±—æ¨¡æ§˜
        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        for(let i=0; i<3; i++) {
            for(let j=0; j<3; j++) {
                ctx.beginPath();
                ctx.arc(this.x + 10 - i*10, this.y - 6 + j*6, 4, 0, Math.PI, false);
                ctx.fill();
            }
        }

        // å°¾ã³ã‚Œ
        ctx.fillStyle = '#4682B4';
        ctx.beginPath();
        ctx.moveTo(this.x + 20, this.y);
        ctx.lineTo(this.x + 35, this.y - 12);
        ctx.lineTo(this.x + 35, this.y + 12);
        ctx.fill();

        // èƒ¸ãƒ“ãƒ¬
        ctx.fillStyle = '#87CEFA';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + 3, 8, 4, Math.PI / 4, 0, Math.PI * 2);
        ctx.fill();

        // ç›®
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 12, this.y - 5, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 13, this.y - 5, 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Sardine extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 12;
        this.speed = 2.0; // å°‘ã—é€Ÿã„
        this.angle = Math.random() * Math.PI * 2;
    }
    update(baseSpeed) {
        this.x -= (baseSpeed + this.speed);
        this.y += Math.sin(this.angle += 0.1) * 0.5;
    }
    draw(ctx) {
        const grad = ctx.createLinearGradient(this.x, this.y - 6, this.x, this.y + 6);
        grad.addColorStop(0, '#D3D3D3');
        grad.addColorStop(1, '#A9A9A9');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 15, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        // é’ã„èƒŒä¸­
        ctx.fillStyle = '#4169E1';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y - 2, 12, 4, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Tuna extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 25;
        this.speed = 10.0; // ã¨ã¦ã‚‚é€Ÿã„
    }
    update(baseSpeed) {
        this.x -= (baseSpeed + this.speed);
    }
    draw(ctx) {
        // ãƒ¡ã‚¿ãƒªãƒƒã‚¯ãªãƒœãƒ‡ã‚£
        const grad = ctx.createLinearGradient(this.x - 40, this.y - 20, this.x + 40, this.y + 20);
        grad.addColorStop(0, '#000080'); // Navy
        grad.addColorStop(0.4, '#4169E1'); // RoyalBlue
        grad.addColorStop(1, '#C0C0C0'); // Silver (è…¹)
        ctx.fillStyle = grad;

        // ç´¡éŒ˜å½¢ã®ä½“
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 45, 18, 0, 0, Math.PI * 2);
        ctx.fill();

        // æ¨ªç¸ãƒ©ã‚¤ãƒ³
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.x - 30, this.y);
        ctx.lineTo(this.x + 30, this.y);
        ctx.stroke();

        // é»„è‰²ã„å°é›¢é°­ï¼ˆèƒŒä¸­ã¨è…¹ã®å¾Œã‚ã®æ–¹ã«ã‚ã‚‹ã‚®ã‚¶ã‚®ã‚¶ï¼‰
        ctx.fillStyle = '#FFD700';
        for(let i=0; i<5; i++) {
            // èƒŒå´
            ctx.beginPath();
            ctx.moveTo(this.x + 10 + i*5, this.y - 16);
            ctx.lineTo(this.x + 13 + i*5, this.y - 22);
            ctx.lineTo(this.x + 16 + i*5, this.y - 15);
            ctx.fill();
            // è…¹å´
            ctx.beginPath();
            ctx.moveTo(this.x + 10 + i*5, this.y + 16);
            ctx.lineTo(this.x + 13 + i*5, this.y + 22);
            ctx.lineTo(this.x + 16 + i*5, this.y + 15);
            ctx.fill();
        }

        // ç›®
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 25, this.y - 3, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 25, this.y - 3, 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Shark extends Enemy {
    constructor(x, y, player) {
        super(x, y);
        this.player = player;
        this.radius = 30;
        this.speed = 6.5;
    }
    update(baseSpeed) {
        this.x -= (baseSpeed + this.speed);
        // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®Yåº§æ¨™ã«è¿‘ã¥ãï¼‰
        if (this.player) {
            const dy = this.player.y - this.y;
            this.y += dy * 0.025; // è¿½å°¾æ€§èƒ½ã‚¢ãƒƒãƒ—
        }
    }
    draw(ctx) {
        ctx.fillStyle = '#708090'; // SlateGray
        
        // ä½“
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 40, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // èƒŒã³ã‚Œ
        ctx.beginPath();
        ctx.moveTo(this.x + 5, this.y - 10);
        ctx.lineTo(this.x - 5, this.y - 30);
        ctx.lineTo(this.x - 15, this.y - 10);
        ctx.fill();
        
        // å°¾ã³ã‚Œ
        ctx.beginPath();
        ctx.moveTo(this.x + 35, this.y);
        ctx.lineTo(this.x + 55, this.y - 15);
        ctx.lineTo(this.x + 55, this.y + 15);
        ctx.fill();
        
        // ç›®
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 25, this.y - 5, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 27, this.y - 5, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // ã‚¨ãƒ©
        ctx.strokeStyle = '#506070';
        ctx.lineWidth = 2;
        for(let i=0; i<3; i++) {
            ctx.beginPath();
            ctx.moveTo(this.x - 10 + i*5, this.y - 5);
            ctx.lineTo(this.x - 10 + i*5, this.y + 5);
            ctx.stroke();
        }
    }
}

class Anglerfish extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 25;
        this.angle = Math.random() * Math.PI * 2;
    }
    update(speed) {
        this.x -= speed * 0.7; // å°‘ã—é…ã‚
        this.y += Math.sin(this.angle += 0.03) * 0.5;
    }
    draw(ctx) {
        // æš—ã„ä½“è‰²
        ctx.fillStyle = '#191970'; // MidnightBlue
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 30, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // å£
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.moveTo(this.x - 20, this.y + 5);
        ctx.lineTo(this.x - 10, this.y + 15);
        ctx.lineTo(this.x + 10, this.y + 5);
        ctx.fill();
        
        // æç¯ã®æŸ„
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 25);
        ctx.quadraticCurveTo(this.x + 20, this.y - 50, this.x + 40, this.y - 10);
        ctx.stroke();

        // æç¯ã®å…‰
        ctx.fillStyle = '#ADFF2F'; // GreenYellow
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ADFF2F';
        ctx.beginPath();
        ctx.arc(this.x + 40, this.y - 10, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Hook extends Enemy {
    constructor(x, y) {
        // ç”»é¢å³å´ã«å‡ºç¾ã•ã›ã‚‹
        super(x * 0.8 + Math.random() * (x * 0.2), y);
        this.radius = 10;
        this.vy = 4.5; // è½ä¸‹é€Ÿåº¦ã‚¢ãƒƒãƒ—
    }
    update(speed, game) {
        this.x -= speed; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã«åˆã‚ã›ã¦ç§»å‹•
        this.y += this.vy; // ä¸Šã‹ã‚‰ä¸‹ã¸
        if (game) {
            const groundY = game.getGroundY(this.x);
            if (this.y > groundY) this.y = groundY;
        }
    }
    draw(ctx) {
        const grad = ctx.createLinearGradient(this.x - 5, this.y, this.x + 5, this.y);
        grad.addColorStop(0, '#C0C0C0');
        grad.addColorStop(1, '#696969');
        ctx.strokeStyle = grad;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x, -100); // ç³¸ï¼ˆç”»é¢ä¸Šç«¯ã‚ˆã‚Šä¸Šã¾ã§ç¢ºå®Ÿã«å¼•ãï¼‰
        ctx.lineTo(this.x, this.y);
        ctx.stroke();
        
        // é‡ã®Jã®å­—
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y, 10, 0, Math.PI, false);
        ctx.stroke();
    }
}

class Net extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 80; // å¤§ãã
        this.angle = 0;
    }
    update(speed) {
        this.x -= speed;
        this.y += Math.sin(this.angle += 0.02) * 1;
    }
    draw(ctx) {
        if (!isFinite(this.x) || !isFinite(this.y)) return;

        ctx.strokeStyle = '#5D4037'; // æ¿ƒã„èŒ¶è‰²
        ctx.lineWidth = 3;
        ctx.fillStyle = 'rgba(100, 100, 100, 0.2)'; // è–„æš—ã„ç¶²ã®è‰²
        
        // ä¸Šéƒ¨ã®ãƒ­ãƒ¼ãƒ—
        ctx.beginPath();
        ctx.moveTo(this.x - 60, this.y - 70);
        ctx.quadraticCurveTo(this.x, this.y - 60, this.x + 60, this.y - 70);
        ctx.stroke();

        // æµ®ãï¼ˆãƒ•ãƒ­ãƒ¼ãƒˆï¼‰
        ctx.fillStyle = '#FFD700';
        for(let i=-50; i<=50; i+=25) {
            ctx.beginPath();
            ctx.arc(this.x + i, this.y - 65 + Math.abs(i)*0.1, 5, 0, Math.PI*2);
            ctx.fill();
        }

        // ç¶²è¢‹
        ctx.fillStyle = 'rgba(100, 100, 100, 0.1)';
        ctx.beginPath();
        ctx.moveTo(this.x - 60, this.y - 70);
        ctx.bezierCurveTo(this.x - 70, this.y, this.x - 30, this.y + 70, this.x, this.y + 80);
        ctx.bezierCurveTo(this.x + 30, this.y + 70, this.x + 70, this.y, this.x + 60, this.y - 70);
        ctx.fill();
        ctx.stroke();

        // ç¶²ç›®ï¼ˆã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã—ã¦æç”»ï¼‰
        ctx.save();
        ctx.clip();
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i = -80; i < 80; i += 10) {
            ctx.moveTo(this.x + i, this.y - 80);
            ctx.lineTo(this.x + i - 40, this.y + 100);
            ctx.moveTo(this.x + i, this.y - 80);
            ctx.lineTo(this.x + i + 40, this.y + 100);
        }
        ctx.stroke();
        ctx.restore();
    }
}

class Squid extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 18;
        this.baseY = y;
        this.timer = 0;
    }
    update(speed) {
        this.x -= speed;
        this.timer += 0.05;
        // æ³¢æ‰“ã¤å‹•ãï¼ˆã‚µã‚¤ãƒ³æ³¢ï¼‰
        this.y = this.baseY + Math.sin(this.timer) * 80;
    }
    draw(ctx) {
        const grad = ctx.createRadialGradient(this.x, this.y - 10, 0, this.x, this.y, 20);
        grad.addColorStop(0, '#FFF5EE');
        grad.addColorStop(1, '#FFE4E1');
        ctx.fillStyle = grad;
        
        // é ­ï¼ˆã‚¨ãƒ³ãƒšãƒ©ï¼‰
        ctx.beginPath();
        ctx.ellipse(this.x, this.y - 15, 15, 20, 0, Math.PI, 0); // ä¸ŠåŠåˆ†
        ctx.lineTo(this.x + 15, this.y);
        ctx.lineTo(this.x - 15, this.y);
        ctx.fill();
        
        // ãƒ’ãƒ¬
        ctx.beginPath();
        ctx.moveTo(this.x - 15, this.y - 25);
        ctx.lineTo(this.x - 25, this.y - 15);
        ctx.lineTo(this.x - 13, this.y - 10);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(this.x + 15, this.y - 25);
        ctx.lineTo(this.x + 25, this.y - 15);
        ctx.lineTo(this.x + 13, this.y - 10);
        ctx.fill();

        // è¶³ï¼ˆè§¦è…•ï¼‰
        ctx.strokeStyle = '#FFF5EE';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        for(let i=-10; i<=10; i+=5) {
            ctx.beginPath();
            ctx.moveTo(this.x + i, this.y);
            ctx.quadraticCurveTo(this.x + i + Math.sin(this.timer * 2 + i)*5, this.y + 15, this.x + i, this.y + 30);
            ctx.stroke();
        }
        
        // ç›®
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 8, this.y - 5, 3, 0, Math.PI*2);
        ctx.arc(this.x + 8, this.y - 5, 3, 0, Math.PI*2);
        ctx.fill();
    }
}

class Flatfish extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 15;
        // ç ‚ã«æ“¬æ…‹ã™ã‚‹è‰²
        this.color = '#D2B48C'; 
        this.mouthOpen = 0;
    }
    draw(ctx, isBiting = false) {
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 25);
        grad.addColorStop(0, '#E6CCB3');
        grad.addColorStop(1, this.color);
        ctx.fillStyle = grad;
        ctx.beginPath();
        // å¹³ã¹ã£ãŸã„ä½“
        // æ•é£Ÿæ™‚ã¯å°‘ã—è†¨ã‚‰ã‚€
        const h = isBiting ? 20 : 10;
        ctx.ellipse(this.x, this.y, 25, h, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ç›®
        // æ•é£Ÿæ™‚ã¯ç›®ãŒãƒãƒƒãƒ†ãƒ³ã«ãªã‚‹ãªã©ã®æ¼”å‡ºã‚‚å¯èƒ½ã ãŒã€ã‚·ãƒ³ãƒ—ãƒ«ã«
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 5, 3, 0, Math.PI * 2);
        ctx.arc(this.x + 5, this.y - 5, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 5, 1, 0, Math.PI * 2);
        ctx.arc(this.x + 5, this.y - 5, 1, 0, Math.PI * 2);
        ctx.fill();
    }
}

class SeaUrchin extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 15;
    }
    draw(ctx) {
        const grad = ctx.createRadialGradient(this.x - 3, this.y - 3, 0, this.x, this.y, 10);
        grad.addColorStop(0, '#4F6F6F');
        grad.addColorStop(1, '#2F4F4F');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
        ctx.fill();
        
        // ãƒˆã‚²
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        for(let i=0; i<8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + Math.cos(angle) * 20, this.y + Math.sin(angle) * 20);
            ctx.stroke();
        }
    }
}

class Octopus extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 25;
        this.angle = Math.random() * Math.PI * 2;
        this.moveTimer = 0;
    }
    update(speed) {
        this.x -= speed;
        this.moveTimer += 0.1;
        // æ¿€ã—ã„å‹•ã: å¤§ããªã‚µã‚¤ãƒ³æ³¢ + å°åˆ»ã¿ãªéœ‡ãˆ
        this.y += Math.sin(this.moveTimer) * 4 + Math.sin(this.moveTimer * 3) * 2;
    }
    draw(ctx) {
        const grad = ctx.createRadialGradient(this.x, this.y - 10, 2, this.x, this.y - 5, 15);
        grad.addColorStop(0, '#E9967A');
        grad.addColorStop(1, '#CD5C5C');
        ctx.fillStyle = grad;
        // é ­
        ctx.beginPath();
        ctx.ellipse(this.x, this.y - 15, 20, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // è¶³
        ctx.strokeStyle = '#CD5C5C';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        for(let i=0; i<4; i++) {
            ctx.beginPath();
            const startX = this.x - 15 + i*10;
            ctx.moveTo(startX, this.y);
            const sway = Math.sin(this.moveTimer + i) * 10;
            ctx.quadraticCurveTo(startX + sway, this.y + 20, startX, this.y + 40);
            ctx.stroke();
            
            // å¸ç›¤
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(startX + sway*0.5, this.y + 20, 2, 0, Math.PI*2);
            ctx.fill();
        }

        // ç›®
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 8, this.y - 10, 5, 0, Math.PI * 2);
        ctx.arc(this.x + 8, this.y - 10, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 8, this.y - 10, 2, 0, Math.PI * 2);
        ctx.arc(this.x + 8, this.y - 10, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // å£ï¼ˆã‚¿ã‚³ãƒãƒ¥ãƒ¼ï¼‰
        ctx.strokeStyle = '#8B0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y - 2, 3, 0, Math.PI * 2);
        ctx.stroke();
    }
}

class Porcupinefish extends Enemy {
    constructor(x, y, game) {
        super(x, y);
        this.radius = 20;
        this.game = game;
        this.timer = 0;
        this.hasExploded = false;
    }
    update(speed) {
        this.x -= speed;
        this.timer++;
        // ä¸€å®šæ™‚é–“çµŒéã§é‡ã‚’é£›ã°ã™
        if (!this.hasExploded && this.timer > 120 && this.x < this.game.width - 50) {
            this.explode();
            this.hasExploded = true;
        }
    }
    explode() {
        // 8æ–¹å‘ã«é‡ã‚’ç™ºå°„
        for(let i=0; i<8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            this.game.enemies.push(new Needle(this.x, this.y, Math.cos(angle)*4, Math.sin(angle)*4));
        }
    }
    draw(ctx) {
        const grad = ctx.createRadialGradient(this.x - 5, this.y - 5, 2, this.x, this.y, 20);
        grad.addColorStop(0, '#E6E6FA');
        grad.addColorStop(1, '#9370DB'); // MediumPurple
        ctx.fillStyle = grad;
        ctx.beginPath();
        
        const r = this.hasExploded ? 25 : 20 + Math.sin(this.timer * 0.2) * 2;
        
        // ä½“ï¼ˆå°‘ã—å››è§’ã£ã½ãã—ã¦é­šã‚‰ã—ãï¼‰
        if (!this.hasExploded) {
            ctx.ellipse(this.x, this.y, r + 5, r, 0, 0, Math.PI*2);
        } else {
            ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
        }
        ctx.fill();
        
        // ç›®ï¼ˆæ„›å¬Œã®ã‚ã‚‹æ„Ÿã˜ï¼‰
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 8, this.y - 5, 6, 0, Math.PI * 2);
        ctx.arc(this.x + 8, this.y - 5, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 7, this.y - 5, 2.5, 0, Math.PI * 2);
        ctx.arc(this.x + 9, this.y - 5, 2.5, 0, Math.PI * 2);
        ctx.fill();

        // å£
        ctx.strokeStyle = '#4B0082';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y + 6, 4, 0, Math.PI, false);
        ctx.stroke();

        // ãƒ’ãƒ¬
        ctx.fillStyle = '#9370DB';
        ctx.beginPath();
        ctx.moveTo(this.x - 15, this.y + 5);
        ctx.lineTo(this.x - 25, this.y + 15);
        ctx.lineTo(this.x - 15, this.y + 15);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(this.x + 15, this.y + 5);
        ctx.lineTo(this.x + 25, this.y + 15);
        ctx.lineTo(this.x + 15, this.y + 15);
        ctx.fill();

        // ãƒˆã‚²ï¼ˆé€šå¸¸æ™‚ã‚‚å°‘ã—å‡ºã™ï¼‰
        ctx.strokeStyle = '#8B008B';
        ctx.lineWidth = 2;
        const spikeLen = this.hasExploded ? 25 : 5;
        for(let i=0; i<8; i++) {
            const angle = (Math.PI * 2 / 8) * i + (this.timer * 0.05);
            ctx.moveTo(this.x + Math.cos(angle)*r, this.y + Math.sin(angle)*r);
            ctx.lineTo(this.x + Math.cos(angle)*(r+spikeLen), this.y + Math.sin(angle)*(r+spikeLen));
        }
        ctx.stroke();
    }
}

class Needle extends Enemy {
    constructor(x, y, vx, vy) {
        super(x, y);
        this.vx = vx;
        this.vy = vy;
        this.radius = 5;
    }
    update(speed) {
        this.x += this.vx; // ç”»é¢ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®å½±éŸ¿ã‚’å—ã‘ãªã„ï¼ˆç›¸å¯¾é€Ÿåº¦ã§ã¯ãªã„ï¼‰
        this.x -= speed;   // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆ†ã‚‚å¼•ã
        this.y += this.vy;
    }
    draw(ctx) {
        ctx.strokeStyle = '#696969';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.vx * 3, this.y - this.vy * 3);
        ctx.stroke();
    }
}

class Whirlpool extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 35;
        this.angle = 0;
    }
    update(speed) {
        this.x -= speed;
        this.angle += 0.2;
    }
    draw(ctx) {
        // ã‚½ãƒ•ãƒˆã‚¯ãƒªãƒ¼ãƒ ã®ã‚ˆã†ãªæ¸¦æ½®
        ctx.strokeStyle = 'rgba(224, 255, 255, 0.8)'; // LightCyan
        ctx.lineWidth = 1;
        ctx.beginPath();
        
        const segments = 50;
        for (let i = 0; i < segments; i++) {
            const ratio = i / segments;
            const radius = (1 - ratio) * this.radius;
            const angle = this.angle + i * 0.5;
            const x = this.x + Math.cos(angle) * radius;
            const y = this.y + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        // ä¸­å¿ƒ
        ctx.fillStyle = 'rgba(0, 0, 139, 0.5)'; // DarkBlue
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
        ctx.fill();
    }
}

class Whale extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.radius = 80;
        this.timer = 0;
    }
    update(speed) {
        // ãƒœã‚¹ã¯ã‚†ã£ãã‚Šè¿«ã£ã¦ãã‚‹
        this.x -= speed * 0.8; // ã•ã‚‰ã«é€Ÿã
        this.y += Math.sin(this.timer += 0.02) * 0.5;
    }
    isOffScreen(w, h) { return this.x < -500; }

    draw(ctx) {
        if (!isFinite(this.x) || !isFinite(this.y)) return;

        // ã‹ã£ã“ã„ã„ã‚¯ã‚¸ãƒ©ï¼ˆãƒãƒƒã‚³ã‚¦ã‚¯ã‚¸ãƒ©é¢¨ï¼‰
        const grad = ctx.createLinearGradient(this.x - 150, this.y - 50, this.x + 100, this.y + 50);
        grad.addColorStop(0, '#191970'); // MidnightBlue (èƒŒæ™¯ã¨å·®åˆ¥åŒ–)
        grad.addColorStop(1, '#483D8B'); // DarkSlateBlue
        ctx.fillStyle = grad;
        
        // ä½“
        ctx.beginPath();
        // é ­éƒ¨ï¼ˆå››è§’ãå¤§ããï¼‰
        ctx.moveTo(this.x + 80, this.y - 40);
        ctx.lineTo(this.x - 100, this.y - 50);
        // èƒŒä¸­ã‹ã‚‰å°¾ã¸
        ctx.quadraticCurveTo(this.x + 200, this.y - 40, this.x + 300, this.y);
        // å°¾ã‹ã‚‰è…¹ã¸
        ctx.quadraticCurveTo(this.x + 200, this.y + 40, this.x - 80, this.y + 50);
        // ä¸‹é¡
        ctx.lineTo(this.x + 60, this.y + 40);
        ctx.quadraticCurveTo(this.x + 80, this.y + 20, this.x + 80, this.y - 40);
        ctx.fill();

        // è…¹ã®ç™½ã„éƒ¨åˆ†
        ctx.fillStyle = '#D3D3D3';
        ctx.beginPath();
        ctx.moveTo(this.x - 80, this.y + 50);
        ctx.quadraticCurveTo(this.x + 100, this.y + 40, this.x + 200, this.y + 10);
        ctx.quadraticCurveTo(this.x + 100, this.y + 20, this.x - 60, this.y + 30);
        ctx.fill();

        // èƒ¸ãƒ“ãƒ¬
        ctx.fillStyle = '#191970';
        ctx.beginPath();
        ctx.moveTo(this.x - 20, this.y + 20);
        ctx.quadraticCurveTo(this.x - 40, this.y + 50, this.x - 10, this.y + 40);
        ctx.fill();

        // å°¾ã³ã‚Œ
        ctx.beginPath();
        ctx.moveTo(this.x + 300, this.y);
        ctx.lineTo(this.x + 350, this.y - 30);
        ctx.lineTo(this.x + 350, this.y + 30);
        ctx.fill();

        // ç›®
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 40, this.y + 10, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 41, this.y + 10, 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Pearl {
    constructor(x, y, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 15;
    }
    update(speed, game) {
        this.x -= speed;
        this.x += this.vx;
        this.y += this.vy;
        
        this.vx *= 0.95; // æ‘©æ“¦
        this.vy *= 0.95;

        if (game) {
            const floorY = game.getGroundY(this.x) - 15; // åŠå¾„åˆ†å¼•ã
            if (this.y < floorY) {
                this.vy += 0.2; // é‡åŠ›
            } else if (this.y > floorY) {
                this.y = floorY;
                this.vy = -this.vy * 0.6; // ãƒã‚¦ãƒ³ãƒ‰
                if(Math.abs(this.vy) < 1) this.vy = 0;
            }
        }
    }
    isOffScreen() { return this.x < -50; }
    checkCollision(player) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        return Math.sqrt(dx*dx + dy*dy) < (this.radius + player.radius);
    }
    draw(ctx) {
        // è²æ®»
        ctx.fillStyle = '#FFB6C1'; // LightPink
        ctx.beginPath();
        ctx.arc(this.x, this.y + 10, 15, Math.PI, 0);
        ctx.lineTo(this.x, this.y + 20); // è¶ç•ª
        ctx.fill();
        
        // è²æ®»ã®ç­‹
        ctx.strokeStyle = '#FF69B4';
        ctx.lineWidth = 1;
        for(let i=1; i<5; i++) {
            const angle = Math.PI + (Math.PI / 5) * i;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + 15);
            ctx.lineTo(this.x + Math.cos(angle)*15, this.y + 10 + Math.sin(angle)*15);
            ctx.stroke();
        }

        // çœŸç 
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(this.x, this.y + 5, 7, 0, Math.PI * 2);
        ctx.fill();
        // çœŸç ã®è¼ã
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 2, this.y + 3, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Plankton {
    constructor(x, y, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 8;
        this.angle = Math.random() * Math.PI * 2;
    }
    update(speed) {
        this.x -= speed;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95;
        this.vy *= 0.95;
        this.y += Math.sin(this.angle += 0.1) * 0.5; // ãµã‚ãµã‚
    }
    isOffScreen() { return this.x < -50; }
    checkCollision(player) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        return Math.sqrt(dx*dx + dy*dy) < (this.radius + player.radius);
    }
    draw(ctx) {
        // ãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³ï¼ˆå¾®ç”Ÿç‰©é¢¨ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰
        ctx.fillStyle = 'rgba(152, 251, 152, 0.4)'; // PaleGreen, translucent
        ctx.beginPath();
        // å°‘ã—æ­ªã‚“ã å††
        const r = this.radius;
        ctx.moveTo(this.x + r, this.y);
        for(let i=1; i<=8; i++) {
            const angle = i * Math.PI / 4;
            const dist = r + Math.sin(Date.now() / 200 + i * 2) * 2;
            ctx.lineTo(this.x + Math.cos(angle) * dist, this.y + Math.sin(angle) * dist);
        }
        ctx.closePath();
        ctx.fill();

        // æ ¸
        ctx.fillStyle = '#32CD32'; // LimeGreen
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // å†…éƒ¨ã®ç²’
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        for(let i=0; i<3; i++) {
            ctx.beginPath();
            ctx.arc(this.x + (Math.random()-0.5)*6, this.y + (Math.random()-0.5)*6, 1, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.shadowBlur = 5;
        ctx.shadowColor = '#90EE90';
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class FriendShrimp extends Plankton {
    constructor(x, y) {
        super(x, y);
        this.radius = 12;
    }
    draw(ctx) {
        // ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦ã®ä»²é–“ã‚¨ãƒ“ã‚‚ã‚¨ãƒ“ã‚‰ã—ã„è¦‹ãŸç›®ã«
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = '#FFB6C1'; // LightPink
        
        // ä½“
        ctx.beginPath();
        ctx.ellipse(0, 0, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ç¯€
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.arc(-3, -2, 3, 0, Math.PI, false);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(3, -2, 3, 0, Math.PI, false);
        ctx.fill();

        // å°»å°¾
        ctx.fillStyle = '#FFB6C1';
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.lineTo(-16, 5);
        ctx.lineTo(-16, -5);
        ctx.fill();
        
        // ç›®
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(8, -2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
}

class Seaweed {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.height = Math.random() * 100 + 80; // å¤§ããã™ã‚‹
        this.swayOffset = Math.random() * Math.PI * 2;
    }
    update(speed) { this.x -= speed; }
    draw(ctx, frameCount) {
        const sway = Math.sin(frameCount * 0.05 + this.swayOffset) * 20;
        ctx.strokeStyle = '#2E8B57'; // SeaGreen
        ctx.lineWidth = 10; // å¤ªãã™ã‚‹
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.quadraticCurveTo(this.x + sway, this.y - this.height / 2, this.x + sway * 0.5, this.y - this.height);
        ctx.stroke();
    }
}

class RuggedTerrain {
    constructor(x, y) {
        this.x = x;
        this.y = y; // ç”»é¢ã®é«˜ã•
        this.width = Math.random() * 300 + 200; // å¹…ã‚’å¤§ãã
        this.baseHeight = Math.random() * 150 + 80; // é«˜ã•ã‚’å¤§ãã
        this.points = [];
        const segments = 10;
        for (let i = 0; i <= segments; i++) {
            const px = this.x + (i / segments) * this.width;
            // é ‚ç‚¹ã‚’ã‚ˆã‚Šã‚®ã‚¶ã‚®ã‚¶ã«
            const py = this.y - this.baseHeight - (Math.random() - 0.5) * 60;
            this.points.push({x: px, y: py});
        }
    }
    update(speed, game) { 
        this.x -= speed;
        this.points.forEach(p => p.x -= speed);
        // ç ‚ã®ã†ã­ã‚Šã«åˆã‚ã›ã‚‹å¿…è¦ã¯ãªã„ã®ã§ã€yã®æ›´æ–°ã¯å‰Šé™¤
    }
    draw(ctx) {
        const grad = ctx.createLinearGradient(this.x, this.y - this.baseHeight, this.x, this.y);
        grad.addColorStop(0, '#505050');
        grad.addColorStop(1, '#303030');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.y);
        this.points.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(this.points[this.points.length - 1].x, this.y);
        ctx.fill();

        // ãƒã‚¤ãƒ©ã‚¤ãƒˆã¨ã‚·ãƒ£ãƒ‰ã‚¦ã§ç«‹ä½“æ„Ÿã‚’å‡ºã™
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        for(let i=1; i<this.points.length; i++) {
            ctx.lineTo(this.points[i].x, this.points[i].y);
        }
        ctx.stroke();
    }
    
    getSurfaceY(x) {
        for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i+1];
            if (x >= p1.x && x <= p2.x && p1.x !== p2.x) {
                const ratio = (x - p1.x) / (p2.x - p1.x);
                return p1.y + (p2.y - p1.y) * ratio;
            }
        }
        return this.y; // ç¯„å›²å¤–ãªã‚‰åœ°é¢ã®é«˜ã•
    }

    checkSideCollision(player) {
        // å·¦å´é¢ã¨ã®è¡çªåˆ¤å®šï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå²©ã®å·¦å´ã«ã„ã‚‹å ´åˆã®ã¿ï¼‰
        if (player.x > this.points[0].x) return false;

        const leftEdgeTop = this.points[0];
        const leftEdgeBottom = {x: this.points[0].x, y: this.y};
        const dist = this.distToSegment(player, leftEdgeTop, leftEdgeBottom);
        return dist < player.radius;
    }

    distToSegment(p, v, w) {
        const l2 = (w.x - v.x)**2 + (w.y - v.y)**2;
        if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.sqrt((p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2);
    }
}

class Coral {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.color = ['#CD5C5C', '#B22222', '#8B4513'][Math.floor(Math.random() * 3)];
        this.branches = [];
        // æåˆ†ã‹ã‚Œã—ãŸã‚µãƒ³ã‚´
        for(let i=0; i<8; i++) {
            const h = Math.random() * 50 + 30;
            const angle = (Math.random() - 0.5) * 1.0; // å‚¾ã
            this.branches.push({
                x: (Math.random() - 0.5) * 40,
                h: h,
                w: Math.random() * 8 + 4,
                angle: angle
            });
        }
    }
    update(speed) { this.x -= speed; }
    draw(ctx) {
        ctx.fillStyle = this.color;
        this.branches.forEach(b => {
            ctx.beginPath();
            ctx.save();
            ctx.translate(this.x + b.x, this.y);
            ctx.rotate(b.angle);
            ctx.roundRect(-b.w/2, -b.h, b.w, b.h, b.w/2);
            ctx.fill();
            ctx.restore();
        });
        // èƒŒæ™¯ã¨ã—ã¦é¦´æŸ“ã¾ã›ã‚‹
        ctx.fillStyle = 'rgba(0, 20, 40, 0.2)';
        this.branches.forEach(b => {
            ctx.beginPath();
            ctx.save();
            ctx.translate(this.x + b.x, this.y);
            ctx.rotate(b.angle);
            ctx.roundRect(-b.w/2, -b.h, b.w, b.h, b.w/2);
            ctx.fill();
            ctx.restore();
        });
    }
}

class Clownfish {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 12;
        this.angle = 0;
    }
    update(speed) {
        this.x -= speed;
        this.y += Math.sin(this.angle += 0.1) * 0.5;
    }
    isOffScreen() { return this.x < -50; }
    checkCollision(player) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        return Math.sqrt(dx*dx + dy*dy) < (this.radius + player.radius);
    }
    draw(ctx) {
        // ã‚«ã‚¯ãƒ¬ã‚¯ãƒãƒãƒŸï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ã«ç™½å¸¯ï¼‰
        ctx.fillStyle = '#FF4500'; // OrangeRed
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 15, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ç™½å¸¯
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.fillRect(this.x - 5, this.y - 7, 3, 14);
        ctx.fillRect(this.x + 3, this.y - 6, 3, 12);
        ctx.fill();
        
        // ç›®
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 8, this.y - 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }
}

class GardenEel {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 10;
        this.height = 30;
    }
    update(speed) {
        this.x -= speed;
    }
    isOffScreen() { return this.x < -50; }
    checkCollision(player) {
        const dx = this.x - player.x;
        const dy = (this.y - 15) - player.y; // å½“ãŸã‚Šåˆ¤å®šã¯é ­ä»˜è¿‘
        return Math.sqrt(dx*dx + dy*dy) < (this.radius + player.radius);
    }
    draw(ctx) {
        // ãƒãƒ³ã‚¢ãƒŠã‚´ï¼ˆç™½ã«é»’ç‚¹ï¼‰
        ctx.fillStyle = '#F0F8FF'; // AliceBlue
        ctx.beginPath();
        ctx.roundRect(this.x - 4, this.y - this.height, 8, this.height, 4);
        ctx.fill();
        
        // é»’ç‚¹
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x, this.y - 20, 1.5, 0, Math.PI * 2);
        ctx.arc(this.x, this.y - 10, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // ç›®
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 2, this.y - 26, 1, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Bubble {
    constructor(x, y, isBackground = false) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 5 + 2;
        this.isBackground = isBackground;
        
        if (isBackground) {
            this.life = Math.random() * 0.5 + 0.1; // èƒŒæ™¯ç”¨ã¯è–„ã
            this.decay = 0.002 + Math.random() * 0.003; // é•·æŒã¡
            this.vy = Math.random() * 1.5 + 0.5; // ä¸Šæ˜‡é€Ÿåº¦
            this.vxFactor = 0.1; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å½±éŸ¿å°‘ãªã‚ï¼ˆé æ™¯æ„Ÿï¼‰
        } else {
            this.life = 1.0;
            this.decay = 0.02;
            this.vy = 1;
            this.vxFactor = 0.5;
        }
    }
    update(speed) {
        this.x -= speed * this.vxFactor;
        this.y -= this.vy;
        this.life -= this.decay;
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(255, 255, 255, ${Math.max(0, this.life)})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

class StreamLine {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.length = Math.random() * 100 + 50;
    }
    update(speed) {
        this.x -= speed;
    }
    draw(ctx) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.length, this.y);
        ctx.stroke();
    }
}

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 1.0;
        this.vy = -1.5;
    }
    update() {
        this.y += this.vy;
        this.life -= 0.02;
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.font = 'bold 24px "M PLUS Rounded 1c", sans-serif';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 4;
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
}

// ã‚²ãƒ¼ãƒ é–‹å§‹
window.onload = () => new Game();

</script>
</body>
</html>
